<!DOCTYPE html>
<head>
 <meta charset="utf-8">
 <title>Automorphism</title>
 <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans|Open+Sans+Condensed:Light&display=swap">
 <style>
  #theoutput {
   width: 45vw;
   clear: both;
   float: left;
   border: 1px solid red;
   padding: 5px;
   font-family: monospace, monospace;
   font-size: 8px;
  }
  #theinput {
   float: left;
   padding: 10px;
  }
  #thegraph {
   width: 45vw;
   height: 45vw; /* ie. square */
   border: 1px solid green;
   padding: 5px;
   font-family: monospace, monospace;
   float: left;
  }
  .red {
   color: red;
  }
  .toobig {
   color: yellow;
   background-color: red;
  }
  form {
   margin: 10px;
  }
  label {
   display: inline-block;
   width: 180px;
   font-size: 12px;
   text-align: right;
   margin-right: 10px;
  }
  input[type=range] {
   vertical-align: middle;
   margin: 4px;
  }
  input[type=checkbox] {
   vertical-align: middle;
  }
  input[type=text] {
   margin: 4px;
  }
  button {
   border-radius: 2px;
   font-size: 16px;
  }
 </style>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.18.1/cytoscape.min.js" integrity="sha512-MgZAJudXekIHKoFtEk1NUwpSSCDt6JlfkUdwgX/1ustAyJltGO82ayHPOyK31xy9q84nGecgtF+D9hdm2OZldg==" crossorigin="anonymous"></script>
 <script src="https://cytoscape.org/cytoscape.js-euler/cytoscape-euler.js"></script>
</head>
<body onload="manageControls();">

<form id="theinput" method="POST" oninput="manageControls();">
  <label for="input_valency">Valency:</label><input type="range" id="input_valency" value="3" min="2" max="10" /> <output id="output_valency"></output><br/>
  <label for="input_maxdepth">Depth:</label><input type="range" id="input_maxdepth" value="3" min="0" max="8" /> <output id="output_maxdepth"></output><br/>
  <span style="font-weight:bold;color:green;"><label for="output_Nnodes">Nodes:</label><output id="output_Nnodes"></output></span><br/>

  <label for="input_extent">Original nodes only:</label><input type="checkbox" id="input_extent" /> <output id="output_extent"></output><br/>
  <label for="input_labels">Label nodes:</label><input type="checkbox" checked id="input_labels" /> <output id="output_labels"></output><br/>
<!--  <label for="input_addresses">Use address:</label><input type="checkbox" checked id="input_addresses" /> <output id="output_addresses"></output><br/>-->
  <label for="input_xlabels">Original labels too:</label><input type="checkbox" id="input_xlabels" /> <output id="output_xlabels"></output><br/>
  <label for="input_showdists">Show distances:</label><input type="checkbox" id="input_showdists" /> <output id="output_showdists"></output><br/>
  <label for="input_nodesize">Size nodes by distance:</label><input type="checkbox" checked id="input_nodesize" /> <output id="output_nodesize"></output><br/>

  <br/>

  <button onclick="run();return false;">Run</button>
  <button onclick="copy('theoutput');return false;">Copy Output</button>
  <button id="gvbutton" disabled="true" onclick="window.open(makeGraphVizLink(G),'_blank');return false;" title="Opens in new tab/window">GraphViz</button>

  <select id="input_layout" onchange="drawCytoscapeGraph();return false;">
   <option value="none" selected>none</option>
   <option value="null">null</option>
   <option value="grid">grid</option>
   <option value="random">random</option>
   <option value="cose">cose</option>
<!--   <option value="euler">euler</option>-->
  </select>
  <br/>
</form>

<div id="theoutput" title="Click to copy">Dot code will be shown here. GraphViz button opens the result in a new tab/window.</div>
<svg id="notthegraph"><g/></svg>
<div id="thegraph"></div>

<script>
 // set up some constants
 const Pi = Math.acos(-1);
 const thelabels = "rbgmckyabcdefghijklmnopqrstuvwxyz0123456789".split(""); // used for dot language output [using first three colour initials]
 const EDGESEP = " -- "; // dot language output separator (-- or ->)
 const ROOTNODE = "\u{d8}"; // capital-O-with-stroke symbol https://graphemica.com/%C3%98
// const colours=["red","blue","green","magenta","cyan","black","yellow"];
 const colours=["#ff0000","#0000ff","#00ff00","#ff00ff","#00ffff","#000000","#ffff00"];

// function to provide label characters //////////////////////////////////////////////////////////// fn:label
function label(n){
 return (n>=0 & n<thelabels.length ? thelabels[n] : "X"); // return "X" if n is out of range
}

// function to label a whole node ////////////////////////////////////////////////////////////////// fn: labelNode
function labelNode(node){
 if (node!=null){
  thelabel = node.map(label).join("");
  if (thelabel.length==0) thelabel = ROOTNODE;
  return thelabel;
 } else {
  return null;
 }
}

// function to turn the nodes and edges into a cytoscape data structure //////////////////////////// fn: mkcyto
function mkcyto(){
 var thedata = [];
 for (var i=0;i<thenodes.length;i++){
  // label the nodes:
  var thislabel = labelNode(thenewnodes[i]); // get the label of the node's destination
  var thisclass = "";
  if (thislabel==null){
   thislabel = i;
   thisclass = "faded";
  }
//  var finallabel = labelNode(thenodes[i])+" -> "+thislabel;
  var finallabel = thislabel;

  var thisnode = {
   "data": {
    "id": "node"+i,
    "label": finallabel,
    "weight": 4
   },
   "position": {
// omit pre-computed positions for now
//    "x": 150,
//    "y": 45
   },
   "group": "nodes",
   "removed": false,
   "selected": false,
   "selectable": true,
   "locked": false,
   "grabbable": true,
   "css": {
     "color": (thisclass=="faded"?"#bbb":"black"),
     "background-color": (thisclass=="faded"?"#777":"#3b3"),
   },
   "classes": ""
  };
  thedata.push(thisnode);
 }


 for (var i=0;i<theedges.length;i++){
  var from = thenodes[theedges[i][0]].join("");
  var to = thenodes[theedges[i][1]].join("");
  var thiscolour = colours[to[to.length-1]];

  var thisedge = {
   "data": {
    "id": "edge"+i,
    "weight": 12,
    "source": "node"+theedges[i][0],
    "target": "node"+theedges[i][1]
   },
   "position": {},
   "group": "edges",
   "removed": false,
   "selected": false,
   "selectable": true,
   "locked": false,
   "grabbable": true,
   "css": {"line-color": thiscolour},
//   "target-arrow-shape": "none",
   "classes": ""
   };
   thedata.push(thisedge);
  };


 // finished, return the object containing the nodes and edges:
 return thedata;
}


// function to turn nodes and edges into dot output //////////////////////////////////////////////// fn: mkdot
function mkdot(){
 var maxdepth = parseInt(document.getElementById("input_maxdepth").value);
 var valency = parseInt(document.getElementById("input_valency").value);

 var showlabels = document.getElementById("input_labels").checked;
// var showaddresses = document.getElementById("input_addresses").checked;
 var showaddresses = true;
 var showoriglabels = document.getElementById("input_xlabels").checked;
 var showdists = document.getElementById("input_showdists").checked;
 var sizebydist = document.getElementById("input_nodesize").checked;


 var thisgraph = 'graph {\n';
 thisgraph += '\t// valency = '+valency+', depth = '+maxdepth+'\n\n';
 thisgraph += '\tedge [penwidth=1, color=black]\n';
 thisgraph += '\tnode [shape=circle, color=none, style=filled, fillcolor="#eaeaea22", fontsize=14, fixedsize=true, fontcolor="#aaaaaa"]\n'; // 88888844
 thisgraph += '\tranksep=2\n';
 thisgraph += '\n\t// EDGES\n';
 for (var i=0;i<theedges.length;i++){
  var from = thenodes[theedges[i][0]].join("");
  var to = thenodes[theedges[i][1]].join("");
  if (showaddresses){
   var fromLabel = labelNode(thenewnodes[theedges[i][0]]);
   var toLabel = labelNode(thenewnodes[theedges[i][1]]);
  } else {
   var fromLabel = from;
   var toLabel = to;
   if (fromLabel.length==0) fromLabel = ROOTNODE;
   if (toLabel.length==0) toLabel = ROOTNODE;
  }

  // some labels might be missing post-automorphism, so use the index instead
  var fadeedge = false;
  if (fromLabel==null || toLabel==null) fadeedge = true;
  if (fromLabel==null) fromLabel = theedges[i][0];
  if (toLabel==null) toLabel = theedges[i][1];

  thiscolour = colours[to[to.length-1]]
//  thisgraph += '\t' + fromLabel + EDGESEP + toLabel + '\n'; // no coloured edges (all black)
//  thisgraph += '\t' + fromLabel + EDGESEP + toLabel + ' [color='+thiscolour+']\n'; // coloured edges
  thisgraph += '\t' + fromLabel + EDGESEP + toLabel + ' [color="'+thiscolour+(fadeedge?'22':'')+'"]\n'; // coloured edges, faded if either end is not defined in the automorphism
 }

 thisgraph += '\n\t// POST-AUTOMORPHISM NODES\n';
 for (var i=0;i<thenewnodes.length;i++){
  var thislabel = labelNode(thenewnodes[i]);
  var nodecolour = 'green';
  var fontcolour = '"#ff0000"';
  var xlabel = labelNode(thenodes[i]);
  var thisradius = 0.1;
  var showdist = '';

  // if there is an entry in thenewnodes, set the properties of the node
  if (thislabel!=null){
   if (labelNode(thenewnodes[i])==labelNode(autoFrom)){
    nodecolour = 'yellow';
    fontcolour = 'black';
   }

   if (autodistance[thenewnodes[i].toString()]!=undefined){
    thisradius = 1/autodistance[thenewnodes[i].toString()];
    showdist = autodistance[thenewnodes[i].toString()];
   } else { // try the old label instead?
    if (autodistance[thenodes[i].toString()]!=undefined){
     thisradius = 5/autodistance[thenodes[i].toString()];
     showdist = autodistance[thenodes[i].toString()];
    } else {
     console.log("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ undefined distance for "+thenewnodes[i].toString());
    }
   }
   thisgraph += '\t' + thislabel + ' ['+(showlabels?'':'label="", ')+'fillcolor=' + nodecolour + ', color=black, fontcolor=' + fontcolour + ', '+(showoriglabels?'xlabel="'+xlabel+(showdists?' ('+showdist+')", ':''):(showdists?'label="'+thislabel+' ('+showdist+')", ':'')) + (sizebydist?'width='+thisradius.toFixed(4):'') + ']\n';
  } else { // otherwise, just add the external label
   thislabel = i;
   xlabel = labelNode(thenodes[i]);
   thisgraph += '\t' + thislabel + ' ['+(showlabels?(showoriglabels?'':(showdists?'label="'+thislabel+' ('+thisdist+')"':'')):'label="", ')+(showoriglabels?'xlabel='+xlabel+', ':'') + ']\n';
  }
 }

 thisgraph += '}\n';
 return thisgraph;
}


function drawCytoscapeGraph(){
 /* good animation example: https://cytoscape.org/cytoscape.js-cose-bilkent/ */
 
 // skip this if the Cytoscape layout is "none":
 if (document.getElementById("input_layout").value=="none"){
  console.log("Skipping Cytoscape graph");
 } else {
  graphData = mkcyto();
  var cy=cytoscape({
   container: document.getElementById("thegraph"),
   elements: graphData,

   style: [ // the stylesheet for the graph
     {
       selector: "node",
       style: {
         "background-color": "#777",
         "label": "data(label)" // was "data(id)"
       }
     },

     {
       selector: "edge",
       style: {
//         "width": 3,
//         "line-color": "#ccc",
//         "target-arrow-color": "#ccc",
//         "target-arrow-shape": "triangle",
         "curve-style": "bezier"
       }
     }
   ],

   layout: {name: document.getElementById("input_layout").value},

  });
 } // end if "none" loop
}

function run(){
 // get values from the user controls:
 var maxdepth = parseInt(document.getElementById("input_maxdepth").value);
 var valency = parseInt(document.getElementById("input_valency").value);
 var valencyList = [];
 for (var v=0;v<valency;v++){
  valencyList.push(v);
 }

 // initialise
 thenodes = [];        // list of nodes by address
 thenodes[0] = [];     // root node
 theedges = [];        // pair-wise edges, using indices
 thenodeindex = [];    // associative array, index by node address
 thenewnodes = [];     // list of nodes by address post-automorphism
 thenewnodeindex = []; // associative array, index by node address, for the post-automorphism graph
 thelocalaction = [];  // list of automorphism permutation at each node (local action)
 autoprogress = [];    // list of flags indicating which nodes have been determined (processed) under the automorphism
 autodistance = [];    // compute how far each node has moved

 thenodeindex["ROOT"] = 0;

 // loop over all nodes and add children to those at the (current) maximum depth
 for (var d=0;d<maxdepth;d++){
  for (var i=0;i<thenodes.length;i++){
   if (thenodes[i].length==d){
    for (var v=0;v<valency;v++){
     if (thenodes[i][thenodes[i].length-1]!=v){ // but only add this node if it really exists (ie. not doubling back on the path)
      thenodes[thenodes.length] = thenodes[i].concat(v);
      // store the index of each node address as well (to aid searching)
      thenodeindex[thenodes[thenodes.length-1].toString()] = thenodes.length-1; // at this point, this is never the root node (we started there, and are adding children)
      // and add an edge at the same time
      theedges.push([i,thenodes.length-1]);
     }
    }
   }
  }
 }

 // initialise the post-automorphism nodes
 for (var i=0;i<thenodes.length;i++){
  thenewnodes[i] = null; // Note: empty value is reserved for the root node, so use null for unspecified nodes
 }

/*
 // now define the automorphism: [THESE WILL COME FROM USER INPUT]
 if (0){
  autoFrom = [0,1,2];
  autoTo = [1,2];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }
 if (0){
  autoFrom = [2];
  autoTo = [1,2];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }
 if (0){
  autoFrom = [2,0,1];
  autoTo = [1,0,2];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }
 if (0){
  autoFrom = [2,1,2];
  autoTo = [1,0,2];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }
 if (0){
  autoFrom = [2,1,2,1];
  autoTo = [1,0,2];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }
 if (1){
  autoFrom = [2];
  autoTo = [1,2,1];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }
*/

 //
 // define the automorphism: [EVENTUALLY THESE WILL COME FROM USER INPUT]
 //
 autoFrom = [0]; // for example
 autoTo = [1]; // for example
 localActionPermutation = permutationCyclic(valencyList,1); // for example

 // the new approach to performing the automorphism:
 // (for now, only define the local action at the reference node)
 thenewnodes[findNode(autoTo,thenodeindex)] = autoFrom; // set the label at the destination
 thenewnodeindex[autoFrom.toString()] = findNode(autoTo,thenodeindex); // put the destination node index into the look-up table of nodes
 thelocalaction[findNode(autoFrom,thenodeindex)] = localActionPermutation;

 // carry out the automorphism:
 processnode(autoFrom,valency);

 // create and draw the Cytoscape graph
 drawCytoscapeGraph();

 // create the dot graph ////////////////////////////////////////////////////////////////////////// make the graph
 G = mkdot();
 document.getElementById("theoutput").innerHTML = "<pre>"+G+"</pre>";
 document.getElementById("theoutput").setAttribute("data-copy-text",G); // for the clipboard
 // feed it to:
 //		https://dreampuf.github.io/GraphvizOnline/

 // turn on the GraphViz button
 if (calcSize()<=5000){
  document.getElementById("gvbutton").removeAttribute("disabled");
 }

 return 0;
} // end run()

// random integers ///////////////////////////////////////////////////////////////////////////////// fn: randomInt
function randomInt(n=1){
 return Math.floor(Math.random()*n); // random integer from the set [0, 1, ..., n-1]
}

// cyclically permute a given list (by a specified "distance") ///////////////////////////////////// fn: permutationCyclic
function permutationCyclic(list,dist=0){
 var out = Array(list.length); // initialise
 while (dist>list.length) dist-=list.length; // avoid winding
 while (dist<0) dist+=list.length; // avoid winding
 for (var i=0;i<(list.length-dist);i++) out[i]=list[i+dist]; // 0 ... dist
 for (var i=list.length-dist;i<list.length;i++) out[i]=list[i+dist-list.length]; // dist+1 ... end
 return out;
}

// randomly permute a given list /////////////////////////////////////////////////////////////////// fn: permutationRandom
function permutationRandom(list){
 var inlist = Array(list.length); // initialise
 var out = Array(list.length); // initialise
 for (var i=0;i<list.length;i++) inlist[i] = list[i]; // make a copy
 for (var i=0;i<list.length;i++) out[i] = inlist.splice(randomInt(inlist.length),1); // extract the elements in random order
 return out;
}

// test a permutation vector for legality ////////////////////////////////////////////////////////// fn: testPermuation
function testPermutation(perm,valency){
 // test for a valid permutation
 if (perm.length==valency){ // right size?
  for (var p=0;p<perm.length;p++){
   if (perm.indexOf(perm[p])!=p){ // repeated entries?
    console.log("ERROR: invalid permutation (repeated entries)");
    return false;
   }
  }
 } else {
  console.log("ERROR: permutation length ("+perm.length+") is not equal to the valency ("+valency+")");
  return false;
 }
 return true;
}

// permute a given list using the provided permutation ///////////////////////////////////////////// fn: permute
function localAction(list,perm,valency){
 // takes a list of a node's neighbours (ie. list length = valency) and permutes them

 if (testPermutation(perm,valency)){
  // legal permutation, so perform the operation
  var out = Array(list.length);
  for (var i=0;i<list.length;i++){
  // permute elements: local action (ie swap the elements of the list around with each other)
   out[i] = list[perm[i]];
//   out[perm[i]] = list[i]; // reverse of standard notation
  }
  return out;
 } else {
  return undefined;
 }
}

// find the neighbours of a given node, for a given valency //////////////////////////////////////// fn: findNeighbours
function findNeighbours(node,valency){
 neighbours = Array(valency); // initialise
 for (var v=0;v<valency;v++){
  if (v==node[node.length-1]){ // check for the "parent" node
   // add the neighbour towards the root node
   neighbours[v] = node.slice(0,node.length-1);
  } else {
   neighbours[v] = node.concat(v);
  }
 }
 return neighbours;
}

// copy the clicked object's contents ////////////////////////////////////////////////////////////// fn: copy
async function copy(targetId=null){
 // Modified from https://www.jasongaylord.com/blog/2020/05/21/copy-to-clipboard-using-javascript
 if (!navigator.clipboard){
  return;
 }

 try {
  if (targetId==null){
   target = event.srcElement;
  } else {
   target = document.getElementById(targetId);
  }
  var copy_value = target.getAttribute("data-copy-text");
  await navigator.clipboard.writeText(copy_value);
 } catch (error){
  console.error("copy failed", error);
 }
}

// create a GraphViz Online link /////////////////////////////////////////////////////////////////// fn: makeGraphVizLink
function makeGraphVizLink(G){
 return "https://dreampuf.github.io/GraphvizOnline/#"+encodeURIComponent(G);
}

// manage the control values and buttons /////////////////////////////////////////////////////////// fn: manageControls
function manageControls(){
 document.getElementById("gvbutton").setAttribute("disabled","true");
 document.getElementById("output_valency").value = parseInt(document.getElementById("input_valency").value);
 document.getElementById("output_maxdepth").value = parseInt(document.getElementById("input_maxdepth").value);
 document.getElementById("output_Nnodes").value = calcSize();

 document.getElementById("output_Nnodes").classList.remove("toobig")
 document.getElementById("gvbutton").classList.remove("toobig")
 document.getElementById("output_Nnodes").classList.remove("red","toobig")
 document.getElementById("gvbutton").classList.remove("toobig")

 if (calcSize()>5000){
  document.getElementById("gvbutton").setAttribute("disabled","true");
  document.getElementById("output_Nnodes").classList.add("toobig")
  document.getElementById("gvbutton").classList.add("toobig")
 } else if (calcSize()>2000){
  document.getElementById("output_Nnodes").classList.add("red")
 }
}

// how big is the graph? /////////////////////////////////////////////////////////////////////////// fn: calcSize
function calcSize(valency=null,maxdepth=null){
 // get the valency and maxdepth if they were not provided:
 if (valency==null) valency = parseInt(document.getElementById("input_valency").value);
 if (maxdepth==null) maxdepth = parseInt(document.getElementById("input_maxdepth").value);
 var N = 0;
 var Nnodes = 0;
 for (var d=0;d<=maxdepth;d++){
  if (d==0){
   N = 1;
  } else if (d==1){
   N = valency;
  } else {
   N = N*(valency-1);
  }
  Nnodes += N;
 }
 return Nnodes;
}


// process the automorphism //////////////////////////////////////////////////////////////////////// fn: processnode
function processnode(v,valency,debug=false){
 console.log("Processing node "+labelNode(v)); // +"                                   ie. "+v.toString()+" (valency="+valency+")");

 var indx = findNode(v,thenodeindex);
 var destindx = thenewnodeindex[v];
 if (v.length==0) destindx = thenewnodeindex["ROOT"];

 var onlyDrawDrawnNodes = document.getElementById("input_extent").checked;

 // has this node been drawn within the current extent of the graph?
 if (onlyDrawDrawnNodes && indx==undefined){
  console.log("    ... stopping at "+labelNode(v)+" [node not drawn]"); // v is off the drawn graph
  autoprogress.push(labelNode(v));
 } else if (destindx==undefined){
  console.log("    ... stopping at "+labelNode(v)+" [destination not drawn]"); // w is off the drawn graph
  autoprogress.push(labelNode(v));
 } else {
  if (autoprogress.indexOf(labelNode(v))>-1){
   console.log("    ... already done node "+labelNode(v));
  } else {
   autoprogress.push(labelNode(v));

   var w = thenodes[destindx]; // address of the destination node
   if (debug) console.log("AUTOMORPHISM: node "+labelNode(v)+" is moving to "+labelNode(w));

   // 1. retrieve the local action, f_v, at this node
   //    -- user-given or
   //    -- (constrained) random or
   //    -- same as at the reference node
   // [EVENTUALLY THESE WILL COME FROM USER INPUT]
   thelocalaction[indx] = localActionPermutation; // for now, use the reference node's local action everywhere

   if (thelocalaction[indx]==null){
    console.log("    ... no local action defined at "+labelNode(v)+", so stopping");
   } else {
    // 2. find this node's neighbours, vi
    var vi = findNeighbours(v,valency); // IN THE ORIGINAL GRAPH
    // 3. permute them according to the local action to give vif (remember that localAction() takes a list of nodes as its input, not a single node)
    var vif = localAction(vi,thelocalaction[indx],valency);
    // 4. find the node's destination's neighbours, wi
    var wi = findNeighbours(w,valency); // POST-MOVE


    if (debug) console.log(" +++ The neighbours of "+labelNode(v)+" are "+vi.map(labelNode).toString());
    if (debug) console.log(" +++ Under the local action they are "+vif.map(labelNode).toString());
    if (debug) console.log(" +++ Their destinations are "+wi.map(labelNode).toString());


    // 3. for each permuted neighbour:
    for (var i=0;i<vif.length;i++){
     if (debug) console.log("     +++ Working on "+labelNode(v)+" neighbour "+labelNode(vi[i])+" ("+findNode(vi[i],thenodeindex)+") -> "+labelNode(vif[i])+" ("+findNode(vif[i],thenodeindex)+") -> "+labelNode(wi[i])+" ("+findNode(wi[i],thenodeindex)+")");

     // find the index of this node's destination *in the "new" graph*
     var neighbourdestindx = findNode(wi[i],thenodeindex);

     // can we draw this destination node?
     if (neighbourdestindx==undefined){
      if (debug) console.log("   "+labelNode(vi[i])+" node destination "+labelNode(vif[i])+" is outside the drawn graph ");
      console.log("    ... skipping "+labelNode(vif[i])+" [destination not drawn]"); // v is off the drawn graph
     } else {

      // only process nodes which were drawn in the original graph:
      if (!onlyDrawDrawnNodes|findNode(vif[i],thenodeindex)!=undefined){
       thenewnodes[neighbourdestindx] = vif[i];

       // update the index for the post-automorphism graph (taking care with the root node):
       var thisnodestring = vif[i].toString();
       if (thisnodestring.length==0) thisnodestring = "ROOT";
       thenewnodeindex[thisnodestring] = neighbourdestindx;

       // how far did the node move?
       autodistance[vif[i].toString()] = nodeDistance(vif[i],wi[i]);
       if (debug) console.log(" ----------------------------------------------------------------- distance from "+labelNode(vif[i])+" to "+labelNode(wi[i])+" is "+autodistance[wi[i].toString()]);
       if (debug) console.log("   --- setting thenewnodeindex["+vif[i].toString()+"] to "+thenewnodeindex[vif[i].toString()]);

       // now work on this neighbour's neighbours:
       if (debug) console.log("Calling processnode(["+vif[i]+"],"+valency+"), ie. processnode(["+labelNode(vif[i])+"],"+valency+")");
       processnode(vif[i],valency);
      }

     }
    }
   }
  }
 }
 return 0;
}

// find the index of a node by its address ///////////////////////////////////////////////////////// fn: findNode
function findNode(v,nodeindex){
 if (v.length){
  return nodeindex[v];
 } else {
  return nodeindex["ROOT"];
 }
}

// find the distance between two node labels /////////////////////////////////////////////////////// fn: labelDistance
function labelDistance(v,w){
 // inputs are labels (ie. strings)
 // THIS DOESN'T WORK FOR THE ROOT NODE...
 // remove common prefix:
 if (v.length>0 & w.length>0){
  while (v[0]==w[0]){
   v=v.substr(1,v.length-1);
   w=w.substr(1,w.length-1);
   if (v.length==0 | w.length==0){
    break;
   }
  }
 }
 // the count what path length is left
 var dist = v.length+w.length;
 return dist;
}
function nodeDistance(v,w){
 // inputs are node addresses, eg. [0,1,2,1]
 // remove common prefix:
 if (v.length>0 & w.length>0){
  while (v[0]==w[0]){
   v=v.slice(1);
   w=w.slice(1);
   if (v.length==0 | w.length==0){
    break;
   }
  }
 }
 // the count what path length is left
 var dist = v.length+w.length;
 return dist;
}

</script>

</body>
</html>
