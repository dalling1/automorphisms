<!DOCTYPE html>
<head>
 <meta charset="utf-8">
 <title>Automorphism</title>
 <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans|Open+Sans+Condensed:Light&display=swap">
 <link rel="stylesheet" href="graphControls.css">
 <link rel="stylesheet" href="localaction.css">
 <style>
  html {
   overflow: hidden;
   background: #333;
/*   font-family: "Open Sans", sans-serif;*/
   font-family: "Open Sans Condensed", sans-serif;
  }
  #graphControls {
   color: #600;
  }
  #thegraph {
   border: 2px solid #446;
   display: block;
   margin: 0 auto;
   box-shadow: inset 3px 3px 3px #bbb;
   background-color: #777;
   text-align: center;

   /* copied from graphControls.css: */
   border: 2px solid black;
   box-shadow: inset -4px -4px 6px #666, -3px 3px 5px #222;
   border-radius: 10px;
  }

  #dotContainer button,
  #graphContainer button {
   font-size: 10px;
   text-transform: uppercase;
   background-color: #bbb;
   padding: 1px 3px;
   box-shadow: 1px 1px 2px #000;
   border-radius: 3px;
  }

  #dotContainer {
   position: relative;
   height: 70vh;
   width: 45vw;
   float: left;
   margin-right: 20px;
  }
  #dotContainer > * {
   position: absolute;
  }
  #dotContainer > button {
   top: 12px;
   right: 5px;
  }

  #graphContainer {
   position: relative;
   height: 70vh;
   width: 45vw;
   float: left;
   margin-right: 20px;
  }
  #graphContainer > * {
   position: absolute;
  }
  #graphContainer > button {
   top: 12px;
   right: -10px;
  }
  #graphContainer > #thedetails {
   bottom: -10px;
   right: -10px;
  }

  #theoutput {
   position: absolute;
   width: 100%;
   height: 100%;
   border: 1px solid red;
   padding: 5px;
   margin: 5px;
   box-sizing: content-box;
   font-family: monospace, monospace;
   font-size: 12px;
   overflow: auto;
   color: yellow;
  }
  #thegraph {
   height: 70vh; /* ie. square */
   width: 45vw;
   padding: 5px;
   margin: 5px;
   box-sizing: content-box;
   float: left;
  }
  #thegraph svg {
   max-height: 100%;
   max-width: 100%;
  }
  #thegraph > svg > g > polygon {
   display: none; /* hide the default background object on the GraphViz graph */
  }
  .red {
   color: red;
  }
  .toobig {
   color: yellow;
   background-color: red;
  }
  form {
   margin: 10px;
  }
  label {
   display: inline-block;
   width: 180px;
   font-size: 12px;
   text-align: right;
   margin-right: 10px;
  }
  input[type=range] {
   vertical-align: middle;
   margin: 4px;
  }
  input[type=checkbox] {
   vertical-align: middle;
  }
  input[type=text] {
   margin: 4px;
  }
  button {
   border-radius: 2px;
   font-size: 16px;
  }
  .node {
   cursor: pointer;
  }
  .node:hover ellipse {
   stroke: #0009;
   stroke-width: 2px;
  }
  .node:hover text {
   fill: #000;
  }
  .referenceNode ellipse {
   fill: #5f56;
  }
  .destinationNode ellipse {
   fill: #f556;
  }

  #colourtable {
   display: inline-block;
   text-align: center;
   vertical-align: middle;
  }
  .valencycolour {
   display: inline-block;
   position: relative;
   width: 90%;
   height: 1em;
   height: 20px;
   background-color: #fff0;
   border-radius: 10px;
  }
  .autoGraph .radius5:hover ellipse,
  .autoGraph .radius7:hover ellipse,
  .autoGraph .radius9:hover ellipse,
  .autoGraph .radius12:hover ellipse,
  .autoGraph .radius18:hover ellipse,
  .autoGraph .radius36:hover ellipse,
  .autoGraph .radius5:hover ~.radius5 ellipse,
  .autoGraph .radius7:hover ~.radius7 ellipse,
  .autoGraph .radius9:hover ~.radius9 ellipse,
  .autoGraph .radius12:hover ~.radius12 ellipse,
  .autoGraph .radius18:hover ~.radius18 ellipse,
  .autoGraph .radius36:hover ~.radius36 ellipse
 {
   fill: #0ff;
  }
  button {
   font-family: "Open Sans", sans-serif;
  }

  #thesvg {
   position: relative;
  }
 </style>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.1/spectrum.min.js"></script>
 <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.1/spectrum.min.css">
 <script src="https://cdn.jsdelivr.net/npm/@hpcc-js/wasm/dist/index.min.js"></script>
 <script>
  var hpccWasm = window["@hpcc-js/wasm"];
 </script>
 <script src="localaction.js"></script>

</head>
<body>

 <div id="graphControls">
  <div class="onecontrol">Valency:<br/>
   <input type="range" id="input_valency" value="3" min="2" max="10" oninput="setOutputValues();"/>
   <output id="output_valency"></output>
  </div>
  <div class="onecontrol">Depth:<br/>
   <input type="range" id="input_maxdepth" value="7" min="0" max="10" oninput="setOutputValues();"/>
   <output id="output_maxdepth"></output>
  </div>

  <div class="onecontrol">Nodes:<br/>
   <output id="output_Nnodes"></output>
  </div>

  <div class="onecontrol">Original nodes only:<br/>
   <label class="switch">
   <input type="checkbox" checked id="input_extent" />
   <span class="slider round"></span>
   </label>
  </div>
  <div class="onecontrol">Label nodes:<br/>
   <label class="switch">
   <input type="checkbox" id="input_labels" />
   <span class="slider round"></span>
   </label>
  </div>
  <div class="onecontrol">Original labels too:<br/>
   <label class="switch">
   <input type="checkbox" id="input_xlabels" />
   <span class="slider round"></span>
   </label>
  </div>
  <div class="onecontrol">Show distances:<br/>
   <label class="switch">
   <input type="checkbox" id="input_showdists" />
   <span class="slider round"></span>
   </label>
  </div>
  <div class="onecontrol">Size nodes by distance:<br/>
   <label class="switch">
   <input type="checkbox" checked id="input_nodesize" />
   <span class="slider round"></span>
   </label>
  </div>

  <div class="onecontrol controlwrapper">
   <span class="wrappertext">Engine</span><br/>
   <select id="input_engine">
    <option value="none">none</option>
    <option value="circo">circo</option>
    <option value="dot">dot</option>
    <option value="fdp">fdp</option>
    <option value="sfdp">sfdp</option>
    <option value="neato" selected>neato</option>
    <option value="osage">osage</option>
    <option value="patchwork">patchwork</option>
    <option value="twopi">twopi</option>
   </select>
  </div>

  <div class="onecontrol controlwrapper">
   <span class="wrappertext">Format</span><br/>
   <select id="input_format">
    <option value="dot" disabled>dot</option>
    <option value="svg" selected>svg</option>
   </select>
  </div>

  <div class="onecontrol controlwrapper">
   <div id="editorwrapper" class="editorwrapper"></div>
   <div style="float:right;text-align:left;">
    Local action<br/>
<!--    <button class="onecontrol" style="font-size:0.8em;" onclick="" title="Reset local action">Info</button><br/>-->
    <button class="onecontrol" style="font-size:0.8em;" onclick="resetLocalAction();" title="Reset local action">Reset</button>
   </div>
  </div>
  <table style="display:none;" id="colourtable"></table>

  <button class="onecontrol" style="font-size:2em;" onclick="run(false);">Original</button>
  <button class="onecontrol" style="font-size:2em;" onclick="run(true);">Automorph</button>

 </div>

<div id="dotContainer">
 <div id="theoutput" data-copy-text="">Dot code will be shown here</div>
 <button onclick="copy('theoutput');" title="Copy dot text">Copy</button>
</div>
<div id="graphContainer">
 <div id="thegraph" data-copy-text=""></div>
 <button style="left:10px;" onclick="toggleLabels();" title="Toggle labels">Labels</button>
 <button style="right:40px;" onclick="clearAutomorphism();" title="Reset automorphism">Reset</button>
 <button onclick="copy('thegraph');" title="Copy SVG code">Copy</button>
 <div id="thedetails"></div>
</div>

<script>
 // set up some constants
 const Pi = Math.acos(-1);
 const thelabels = "rbgmckyabcdefghijklmnopqrstuvwxyz0123456789".split(""); // used for dot language output [using first three colour initials]
 const EDGESEP = " -- "; // dot language output separator (-- or ->)
 const ROOTNODE = "\u{d8}"; // capital-O-with-stroke symbol https://graphemica.com/%C3%98
// const colours=["red","blue","green","magenta","cyan","black","yellow"];
 const colours=["#ff0000","#0000ff","#00ff00","#ff00ff","#00ffff","#000000","#ffff00"];

 // colour set-up of nodes, edges and labels:
 const thenodecolour = '#dddd55'; // '#ccaa00'; // was orange, then yellow
 const theedgecolour = 'black'; // currently a fall-back (each edge's colour is over-ridden individually)
 const thefadednodecolour = '#eaeaea22';
 const thelabelcolour = '#000000';
 const thefadedlabelcolour = '#aaaaaa';
 const thefadeopacity = '77'; // 2-digit hex code
 const thereferencenodecolour = '#55ff5566';
 const thereferencelabelcolour = 'black';
 const thedestinationnodecolour = '#ff555566';
 const thedestinationlabelcolour = 'black';

// function to provide label characters //////////////////////////////////////////////////////////// fn: label
function label(n){
 return (n>=0 && n<thelabels.length ? thelabels[n] : "X"); // return "X" if n is out of range
}

// function to label a whole node ////////////////////////////////////////////////////////////////// fn: labelNode
function labelNode(node){
 if (node!=null){
  thelabel = node.map(label).join("");
  if (thelabel.length==0) thelabel = ROOTNODE;
  return thelabel;
 } else {
  return null;
 }
}

// function to turn nodes and edges into dot output //////////////////////////////////////////////// fn: mkdot
function mkdot(withAutomorphism=false){
 var valency = parseInt(document.getElementById("input_valency").value);
 var maxdepth = parseInt(document.getElementById("input_maxdepth").value);

 var showlabels = document.getElementById("input_labels").checked;
 var showaddresses = true;
 var showoriglabels = document.getElementById("input_xlabels").checked;
 var showdists = document.getElementById("input_showdists").checked;
 var sizebydist = document.getElementById("input_nodesize").checked;


 var thisgraph = 'graph {\n';
 thisgraph += '\t// valency = '+valency+', depth = '+maxdepth+'\n\n';
 thisgraph += '\tedge [penwidth=1, color='+theedgecolour+']\n';
 thisgraph += '\tnode [shape=circle, fixedsize=true, color=none, style=filled, fillcolor="'+(withAutomorphism?thefadednodecolour:thenodecolour)+'"]\n';
 thisgraph += '\tnode [fontsize=14, fontcolor="'+(withAutomorphism?thefadedlabelcolour:thelabelcolour)+'"]\n';
 thisgraph += '\tranksep=2\n';
 thisgraph += '\n\t// EDGES\n';
 var fromLabel = '';
 var toLabel = '';
 for (var i=0;i<theedges.length;i++){
  var from = thenodes[theedges[i][0]].join("");
  var to = thenodes[theedges[i][1]].join("");
  if (showaddresses){
   if (withAutomorphism){
    fromLabel = labelNode(thenewnodes[theedges[i][0]]);
    toLabel = labelNode(thenewnodes[theedges[i][1]]);
   } else {
    fromLabel = labelNode(thenodes[theedges[i][0]]);
    toLabel = labelNode(thenodes[theedges[i][1]]);
   }
  } else {
   fromLabel = from;
   toLabel = to;
   if (fromLabel.length==0) fromLabel = ROOTNODE;
   if (toLabel.length==0) toLabel = ROOTNODE;
  }

  // some labels might be missing post-automorphism, so use the index instead
  var fadeedge = false;
  if (fromLabel==null || toLabel==null) fadeedge = true;
  if (fromLabel==null) fromLabel = theedges[i][0];
  if (toLabel==null) toLabel = theedges[i][1];

  thiscolour = colours[to[to.length-1]]
//  thisgraph += '\t' + fromLabel + EDGESEP + toLabel + '\n'; // no coloured edges (all black)
//  thisgraph += '\t' + fromLabel + EDGESEP + toLabel + ' [color='+thiscolour+']\n'; // coloured edges
  thisgraph += '\t' + fromLabel + EDGESEP + toLabel + ' [color="'+thiscolour+(fadeedge?thefadeopacity:'')+'"]\n'; // coloured edges, faded if either end is not defined in the automorphism
 }

 if (withAutomorphism){
  thisgraph += '\n\t// POST-AUTOMORPHISM NODES\n';
  for (var i=0;i<thenewnodes.length;i++){
   var thislabel = labelNode(thenewnodes[i]);
   var nodecolour = thenodecolour;
   var fontcolour = thelabelcolour;
   var xlabel = labelNode(thenodes[i]);
   var thisradius = 0.1;
   var showdist = null;

   // if there is an entry in thenewnodes, set the properties of the node
   if (thislabel!=null){
    if (autodistance[thenewnodes[i].toString()]!=undefined){
     thisradius = 1/autodistance[thenewnodes[i].toString()];
     showdist = autodistance[thenewnodes[i].toString()];
    } else { // try the old label instead?
     if (autodistance[thenodes[i].toString()]!=undefined){
      thisradius = 5/autodistance[thenodes[i].toString()];
      showdist = autodistance[thenodes[i].toString()];
     } else {
      console.log("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ undefined distance for node "+thenodes[i].toString());
     }
    }
    thisgraph += '\t' + thislabel + ' ['+(showlabels?'':'label="", ')+'fillcolor="' + nodecolour + '", color=none, fontcolor="' + fontcolour + '", '+(showoriglabels?'xlabel="'+xlabel+((showdists&(showdist!=null))?' ('+showdist+')", ':'" '):((showdists&(showdist!=null))?'label="'+thislabel+' ('+showdist+')", ':'')) + ((sizebydist&(showdist!=null))?'width='+thisradius.toFixed(4):'') + ']\n';
   } else { // otherwise, just add the external label
    thislabel = i;
    xlabel = labelNode(thenodes[i]);
    var dotcontent = (showlabels?(showoriglabels?'':((showdists&(showdist!=null))?'label="'+thislabel+' ('+showdist+')"':'')):'label="", ')+(showoriglabels?'xlabel='+xlabel+', ':'');
    if (dotcontent.length) thisgraph += '\t' + thislabel + ' ['+ dotcontent + ']\n'; // omit nodes which have no dot style here (ie. "original graph" nodes, post-automorphism)
   }
  }
 } else {
  // show the original graph: do we want labels on the nodes?
  if (!showlabels){
   thisgraph += '\n';
   thisgraph += '\t// HIDE THE LABELS\n';
   for (var i=0;i<thenodes.length;i++){
    thislabel = i;
    thisgraph += '\t' + labelNode(thenodes[i]) + ' [label=""]\n';
   }
  }
 }

 thisgraph += '}\n';
 return thisgraph;
} // end mkdot

// function to run the GraphViz engine to draw the graph on screen ///////////////////////////////// fn: drawGraph
function drawGraph(G=[],doAutomorphism=false){
 var useformat = document.getElementById("input_format").value;
 var useengine = document.getElementById("input_engine").value;

 // skip drawing if the GraphViz engine is "none" or the graph is not defined
 if (useengine=="none" | G.length==0){
  console.log("Skipping GraphViz graph");
 } else {
  graphData = G;
  hpccWasm.graphviz.layout(graphData, useformat, useengine, ).then(svg => {
   const svgdiv = document.getElementById("thegraph"); // the div where the SVG graph should be attached
   svgdiv.innerHTML = svg;
   document.getElementById("thegraph").setAttribute("data-copy-text",svg); // for the clipboard
   setupNodes(); // set the onclick function for the nodes (now that they exist)
   createArrowMarker(); // attach the SVG code for the arrow head markers
   decorateNodes(doAutomorphism);
  });
  console.log("DRAWING GRAPH");
 }
} // end drawGraph

// function to initiate the original graph and text //////////////////////////////////////////////// fn: run
function run(doAutomorphism=false){
 // get values from the user controls:
 var valency = parseInt(document.getElementById("input_valency").value);
 var maxdepth = parseInt(document.getElementById("input_maxdepth").value);
 var valencyList = [];
 for (var v=0;v<valency;v++){
  valencyList.push(v);
 }

 // initialise
 thenodes = [];        // list of nodes by address
 thenodes[0] = [];     // root node
 theedges = [];        // pair-wise edges, using indices
 thenodeindex = [];    // associative array, index by node address
 thenewnodes = [];     // list of nodes by address post-automorphism
 thenewnodeindex = []; // associative array, index by node address, for the post-automorphism graph
 thelocalaction = [];  // list of automorphism permutation at each node (local action)
 autoprogress = [];    // list of flags indicating which nodes have been determined (processed) under the automorphism
 autodistance = [];    // compute how far each node has moved
 setFrom = true;       // start out by selecting the reference node

 thenodeindex["ROOT"] = 0;

 // loop over all nodes and add children to those at the (current) maximum depth
 for (var d=0;d<maxdepth;d++){
  for (var i=0;i<thenodes.length;i++){
   if (thenodes[i].length==d){
    for (var v=0;v<valency;v++){
     if (thenodes[i][thenodes[i].length-1]!=v){ // but only add this node if it really exists (ie. not doubling back on the path)
      thenodes[thenodes.length] = thenodes[i].concat(v);
      // store the index of each node address as well (to aid searching)
      thenodeindex[thenodes[thenodes.length-1].toString()] = thenodes.length-1; // at this point, this is never the root node (we started there, and are adding children)
      // and add an edge at the same time
      theedges.push([i,thenodes.length-1]);
     }
    }
   }
  }
 }

 // initialise the post-automorphism nodes
 for (var i=0;i<thenodes.length;i++){
  thenewnodes[i] = null; // Note: empty value is reserved for the root node, so use null for unspecified nodes
 }


 if (doAutomorphism && autoFrom!=null && autoTo!=null){
  console.log("###");
  console.log("### Automorphism requested, here we should ask the user to define it (select reference node and destination, then local action(s)...)");
  console.log("###");

  // set an example local action:
//  localActionPermutation = permutationCyclic(valencyList,1); // for example
  //
  // get the automorphism from the local action editor (for now, this is just used as the only local action):
  //
  localActionPermutation = getLocalAction();

  // the new approach to performing the automorphism:
  // (for now, only define the local action at the reference node)
  thenewnodes[findNode(autoTo,thenodeindex)] = autoFrom; // set the label at the destination
  thenewnodeindex[autoFrom.toString()] = findNode(autoTo,thenodeindex); // put the destination node index into the look-up table of nodes
  thelocalaction[findNode(autoFrom,thenodeindex)] = localActionPermutation;

  // carry out the automorphism:
  processnode(autoFrom,valency);
 } else {
//  clearAutomorphism();
 }

 // generate the dot code (for original or automorphed graph)
 G = mkdot(doAutomorphism);
 // ...and display it as text:
 document.getElementById("theoutput").innerHTML = "<pre>"+G+"</pre>";
 document.getElementById("theoutput").setAttribute("data-copy-text",G); // for the clipboard

 // ...and draw it on the screen:
 drawGraph(G,doAutomorphism);
 // alternatively, feed it to:
 //		https://dreampuf.github.io/GraphvizOnline/

 return 0;
} // end run()

// random integers ///////////////////////////////////////////////////////////////////////////////// fn: randomInt
function randomInt(n=1){
 return Math.floor(Math.random()*n); // random integer from the set [0, 1, ..., n-1]
}

// cyclically permute a given list (by a specified "distance") ///////////////////////////////////// fn: permutationCyclic
function permutationCyclic(list,dist=0){
 var out = Array(list.length); // initialise
 while (dist>list.length) dist-=list.length; // avoid winding
 while (dist<0) dist+=list.length; // avoid winding
 for (var i=0;i<(list.length-dist);i++) out[i]=list[i+dist]; // 0 ... dist
 for (var i=list.length-dist;i<list.length;i++) out[i]=list[i+dist-list.length]; // dist+1 ... end
 return out;
}

// randomly permute a given list /////////////////////////////////////////////////////////////////// fn: permutationRandom
function permutationRandom(list){
 var inlist = Array(list.length); // initialise
 var out = Array(list.length); // initialise
 for (var i=0;i<list.length;i++) inlist[i] = list[i]; // make a copy
 for (var i=0;i<list.length;i++) out[i] = inlist.splice(randomInt(inlist.length),1); // extract the elements in random order
 return out;
}

// test a permutation vector for legality ////////////////////////////////////////////////////////// fn: testPermuation
function testPermutation(perm,valency){
 // test for a valid permutation
 if (perm.length==valency){ // right size?
  for (var p=0;p<perm.length;p++){
   if (perm.indexOf(perm[p])!=p){ // repeated entries?
    console.log("ERROR: invalid permutation (repeated entries)");
    return false;
   }
  }
 } else {
  console.log("ERROR: permutation length ("+perm.length+") is not equal to the valency ("+valency+")");
  return false;
 }
 return true;
}

// permute a given list using the provided permutation ///////////////////////////////////////////// fn: permute
function localAction(list,perm,valency){
 // takes a list of a node's neighbours (ie. list length = valency) and permutes them

 if (testPermutation(perm,valency)){
  // legal permutation, so perform the operation
  var out = Array(list.length);
  for (var i=0;i<list.length;i++){
  // permute elements: local action (ie swap the elements of the list around with each other)
   out[perm[i]] = list[i];
//   out[i] = list[perm[i]]; // reverse of standard notation
  }
  return out;
 } else {
  return undefined;
 }
}

// find the neighbours of a given node, for a given valency //////////////////////////////////////// fn: findNeighbours
function findNeighbours(node,valency){
 neighbours = Array(valency); // initialise
 for (var v=0;v<valency;v++){
  if (v==node[node.length-1]){ // check for the "parent" node
   // add the neighbour towards the root node
   neighbours[v] = node.slice(0,node.length-1);
  } else {
   neighbours[v] = node.concat(v);
  }
 }
 return neighbours;
}

// copy the clicked object's contents ////////////////////////////////////////////////////////////// fn: copy
async function copy(targetId=null){
 // Modified from https://www.jasongaylord.com/blog/2020/05/21/copy-to-clipboard-using-javascript
 if (!navigator.clipboard){
  return;
 }

 try {
  if (targetId==null){
   target = event.srcElement;
  } else {
   target = document.getElementById(targetId);
  }
  var copy_value = target.getAttribute("data-copy-text");
  await navigator.clipboard.writeText(copy_value);
 } catch (error){
  console.error("copy failed", error);
 }
}

// create a GraphViz Online link /////////////////////////////////////////////////////////////////// fn: makeGraphVizLink
/*
//function makeGraphVizLink(G){
 return "https://dreampuf.github.io/GraphvizOnline/#"+encodeURIComponent(G);
// return "https://quickchart.io/graphviz?layout=twopi&graph="+encodeURIComponent(G);
}
*/

// manage the control values and buttons /////////////////////////////////////////////////////////// fn: manageControls
function manageControls(){
 document.getElementById("output_valency").value = parseInt(document.getElementById("input_valency").value);
 document.getElementById("output_maxdepth").value = parseInt(document.getElementById("input_maxdepth").value);
 document.getElementById("output_Nnodes").value = calcSize();

 document.getElementById("output_Nnodes").classList.remove("toobig")
 document.getElementById("output_Nnodes").classList.remove("red","toobig")

 if (calcSize()>5000){
  document.getElementById("output_Nnodes").classList.add("toobig")
 } else if (calcSize()>2000){
  document.getElementById("output_Nnodes").classList.add("red")
 }
}

// how many nodes does the graph have? ///////////////////////////////////////////////////////////// fn: calcSize
function calcSize(valency=null,maxdepth=null){
 // get the valency and maxdepth if they were not provided:
 if (valency==null) valency = parseInt(document.getElementById("input_valency").value);
 if (maxdepth==null) maxdepth = parseInt(document.getElementById("input_maxdepth").value);
 var N = 0;
 var Nnodes = 0;
 for (var d=0;d<=maxdepth;d++){
  if (d==0){
   N = 1;
  } else if (d==1){
   N = valency;
  } else {
   N = N*(valency-1);
  }
  Nnodes += N;
 }
 return Nnodes;
}


// process the automorphism //////////////////////////////////////////////////////////////////////// fn: processnode
function processnode(v,valency,verbose=false,debug=false){
 if (verbose) console.log("Processing node "+labelNode(v)); // +"                                   ie. "+v.toString()+" (valency="+valency+")");

 var indx = findNode(v,thenodeindex);
 var destindx = thenewnodeindex[v];

 var onlyDrawDrawnNodes = document.getElementById("input_extent").checked;

 // has this node been drawn within the current extent of the graph?
 if (onlyDrawDrawnNodes && indx==undefined){
  if (verbose) console.log("    ... stopping at "+labelNode(v)+" [node not drawn]"); // v is off the drawn graph
  autoprogress.push(labelNode(v));
 } else if (destindx==undefined){
  if (verbose) console.log("    ... stopping at "+labelNode(v)+" [destination not drawn]"); // w is off the drawn graph
  autoprogress.push(labelNode(v));
 } else {
  if (autoprogress.indexOf(labelNode(v))>-1){
   if (verbose) console.log("    ... already done node "+labelNode(v));
  } else {
   autoprogress.push(labelNode(v));

   var w = thenodes[destindx]; // address of the destination node
   if (debug) console.log("AUTOMORPHISM: node "+labelNode(v)+" is moving to "+labelNode(w));

   // 1. retrieve the local action, f_v, at this node
   //    -- user-given or
   //    -- (constrained) random or
   //    -- same as at the reference node
   // [EVENTUALLY THESE WILL COME FROM USER INPUT]
   console.log("###\n### NOTE: using reference node's local action everywhere\n###");
   thelocalaction[indx] = localActionPermutation; // for now, use the reference node's local action everywhere

   if (thelocalaction[indx]==null){
    if (verbose) console.log("    ... no local action defined at "+labelNode(v)+", so stopping");
   } else {
    // 2. find this node's neighbours, vi
    var vi = findNeighbours(v,valency); // IN THE ORIGINAL GRAPH
    // 3. permute them according to the local action to give vif (remember that localAction() takes a list of nodes as its input, not a single node)
    var vif = localAction(vi,thelocalaction[indx],valency);
    // 4. find the node's destination's neighbours, wi
    var wi = findNeighbours(w,valency); // POST-MOVE


    if (debug) console.log(" +++ The neighbours of "+labelNode(v)+" are "+vi.map(labelNode).toString());
    if (debug) console.log(" +++ Under the local action they are "+vif.map(labelNode).toString());
    if (debug) console.log(" +++ Their destinations are "+wi.map(labelNode).toString());


    // 3. for each permuted neighbour:
    for (var i=0;i<vif.length;i++){
     if (debug) console.log("     +++ Working on "+labelNode(v)+" neighbour "+labelNode(vi[i])+" ("+findNode(vi[i],thenodeindex)+") -> "+labelNode(vif[i])+" ("+findNode(vif[i],thenodeindex)+") -> "+labelNode(wi[i])+" ("+findNode(wi[i],thenodeindex)+")");

     // find the index of this node's destination *in the "new" graph*
     var neighbourdestindx = findNode(wi[i],thenodeindex);

     // can we draw this destination node?
     if (neighbourdestindx==undefined){
      if (debug) console.log("   "+labelNode(vi[i])+" node destination "+labelNode(vif[i])+" is outside the drawn graph ");
      if (verbose) console.log("    ... skipping "+labelNode(vif[i])+" [destination not drawn]"); // v is off the drawn graph
     } else {

      // only process nodes which were drawn in the original graph:
      if (!onlyDrawDrawnNodes|findNode(vif[i],thenodeindex)!=undefined){
       thenewnodes[neighbourdestindx] = vif[i];

       // update the index for the post-automorphism graph (taking care with the root node):
       var thisnodestring = vif[i].toString();
       thenewnodeindex[thisnodestring] = neighbourdestindx;

       // how far did the node move?
       autodistance[vif[i].toString()] = nodeDistance(vif[i],wi[i]);
       if (debug) console.log(" ----------------------------------------------------------------- distance from "+labelNode(vif[i])+" to "+labelNode(wi[i])+" is "+autodistance[wi[i].toString()]);
       if (debug) console.log("   --- setting thenewnodeindex["+vif[i].toString()+"] to "+thenewnodeindex[vif[i].toString()]);

       // now work on this neighbour's neighbours:
       if (debug) console.log("Calling processnode(["+vif[i]+"],"+valency+"), ie. processnode(["+labelNode(vif[i])+"],"+valency+")");
       processnode(vif[i],valency);
      }

     }
    }
   }
  }
 }
 return 0;
}

// find the index of a node by its address ///////////////////////////////////////////////////////// fn: findNode
function findNode(v,nodeindex){
 if (v.length){
  return nodeindex[v];
 } else {
  return nodeindex["ROOT"];
 }
}

// find the distance between two nodes ///////////////////////////////////////////////////////////// fn: labelDistance
function nodeDistance(v,w){
 // inputs are node addresses, eg. [0,1,2,1]
 // remove common prefix:
 if (v.length>0 && w.length>0){
  while (v[0]==w[0]){
   v=v.slice(1);
   w=w.slice(1);
   if (v.length==0 | w.length==0){
    break;
   }
  }
 }
 // the count what path length is left
 var dist = v.length+w.length;
 return dist;
}

// HTML input labelling function /////////////////////////////////////////////////////////////////// fn:setOutputValues
// function which looks for inputs and their labels (containing the input value), and sets the label
// (called on page load, to set the initial labels, and when one of the slider controls changes (valency, maxdepth))
function setOutputValues(){
 var debug = false;

 // display the calculated number of nodes that these control choices (valency, depth) will produce:
 document.getElementById("output_Nnodes").value = calcSize();

 // set the max allowed valency to the number of defined colours (add more if we want this to be higher):
 document.getElementById("input_valency").max = colours.length;

 var inputs = document.getElementsByTagName("input"); // get a list of the page inputs
 for (var i=0;i<inputs.length;i++){ // loop over the inputs
  if (inputs[i].id.length && !inputs[i].classList.contains("pickertheme")){ // omit the colour pickers from this process
   if (debug) console.log("examining "+inputs[i].id);
   outputID = inputs[i].id.replace('input_','output_');
   if (!!document.getElementById(outputID)){ // does an output tag for this control exist?
    document.getElementById(outputID).value = inputs[i].value; // set the value of the output to the input
   }
  } else {
//   console.log("skipping "+inputs[i].id);
  }
 }

 // turn on and off the appropriate colour pickers according to the selected valency:
 var valency = parseInt(document.getElementById("input_valency").value);
 for (var i=1;i<=valency;i++){ // on
  var pickername = "picker"+i;
  if (debug) console.log("Showing "+pickername);
  document.getElementById(pickername).nextSibling.style.display="block";
 }
 for (var j=i;j<=colours.length;j++){ // off
  var pickername = "picker"+j;
  if (debug) console.log("Hiding "+pickername);
  document.getElementById(pickername).nextSibling.style.display="none";
 }

 // display the appropriately-sized local action editor
 showEditor(valency);
}

// set the hover/click functionality of nodes ////////////////////////////////////////////////////// fn:setupNodes
function setupNodes(){
 var debug = false;

 var allnodes = document.getElementsByTagName("g");
 for (var i=0;i<allnodes.length;i++){
  if (allnodes[i].classList.contains("node")){ // only set onclick for the nodes (not edges)
   /*
      HERE WE DEFINED THE ON-CLICK FUNCTION FOR NODES:
      - it will register the reference and destination nodes (alternatively)
      - and add styling to those nodes
   */
   allnodes[i].onclick = function() {
    var thisnodeid = this.id;
    var thisnodelabel = this.querySelector(Node="title").textContent;
    if (setFrom){
     // set the reference node
     autoFrom = labelToNode(thisnodelabel);
    } else {
     // set the destination node
     autoTo = labelToNode(thisnodelabel);
    }
    setFrom = !setFrom; // toggle between setting autoFrom and autoTo
    // insert the autoFrom and autoTo nodes into the details div
    fromstring = labelNode(autoFrom);
    tostring = labelNode(autoTo);
    document.getElementById("thedetails").innerHTML = (fromstring==null?"?":fromstring)+" &#8614; "+(tostring==null?"?":tostring);
    decorateNodes();
   } // end of node onclick function
  }
 }

 // "decorate" the nodes: show the automorphism
 decorateNodes();
}

// initialise the automorphism ///////////////////////////////////////////////////////////////////// fn: clearAutomorphism
function clearAutomorphism(){
 autoFrom = null;
 autoTo = null;
 thelocalaction = [];  // list of automorphism permutation at each node (local action)
 autoprogress = [];    // list of flags indicating which nodes have been determined (processed) under the automorphism
 autodistance = [];    // compute how far each node has moved
 decorateNodes();
}

// inverse function from label (string, eg. 'grb') to node (address, eg. [2,0,1]) ////////////////// fn: labelToNode
function labelToNode(thelabel=''){
 var thenode = [];
 for (var i=0;i<thelabel.length;i++){
  var indx = thelabels.indexOf(thelabel[i]);
  if (indx>-1) thenode.push(indx);
 }
 return thenode;
}

// function to find the SVG for a given node, by label ///////////////////////////////////////////// fn: findSVGNode
function findSVGNode(nodelabel=null){
 if (nodelabel!=null){
  var allnodes=document.getElementsByClassName("node");
  for (var j=0;j<allnodes.length;j++){
   if (nodelabel==allnodes[j].querySelector(Node="title").textContent){
    return allnodes[j].id;
   }
  }
 }
 return null;
}

// function to get the coordinates (x,y) of an SVG node drawn on the page, by label //////////////// fn: findCoords
function findCoords(nodelabel=null){
 thisnode = findSVGNode(nodelabel);
 if (thisnode!=null){
  var x = parseFloat(document.getElementById(thisnode).querySelector(Node="ellipse").attributes.cx.value);
  var y = parseFloat(document.getElementById(thisnode).querySelector(Node="ellipse").attributes.cy.value);
  var r = parseFloat(document.getElementById(thisnode).querySelector(Node="ellipse").attributes.rx.value); // assume equal to ry
 }
 return [x,y,r];
}

// calculate the Euclidean distance between two points ///////////////////////////////////////////// fn: euclideanDistance
function euclideanDistance(p1,p2){
 return Math.pow(Math.pow(p1[0]-p2[0],2.0)+Math.pow(p1[1]-p2[1],2.0),0.5);
}

// find the midpoint of two coordinates //////////////////////////////////////////////////////////// fn: lineMidPoint
function lineMidPoint(start,end,factor=0.5){
 var alongX = start[0]+factor*(end[0]-start[0]);
 var alongY = start[1]+factor*(end[1]-start[1]);
 return [alongX,alongY];
}

// function to create an arrow between two nodes /////////////////////////////////////////////////// fn: addArrow
function addArrow(startNode,endNode){
 // create an SVG path between the given nodes
 startPosition=findCoords(startNode);
 endPosition=findCoords(endNode);
 d=createPath(startPosition[0],startPosition[1],endPosition[0],endPosition[1],-1); // -1 for default curvature

 // helper variables
 const ABS_PATH = 0;
 const RELATIVE_PATH = 1;
 const USE_OFFSET = -1; // -1 gives default curves in createPath()

 // generate the path that we want to draw:
 var thepathAbs = createPath(startPosition[0],startPosition[1],endPosition[0],endPosition[1],USE_OFFSET,ABS_PATH);
 // generate the path that we want the label to follow:
 var thepathRel = createPath(startPosition[0],startPosition[1],endPosition[0],endPosition[1],USE_OFFSET,RELATIVE_PATH);

 // remove the old one?
 var oldpath = document.getElementById("thearrow");
 if (oldpath!=null) oldpath.remove();

 // create a new one:
 var newpath = document.createElementNS("http://www.w3.org/2000/svg","path");
 newpath.id = "thearrow";
 newpath.style.fill = "none";
 newpath.style.stroke = "#0003";
 newpath.setAttribute("stroke-width",3);
 newpath.setAttribute("d",d);
 newpath.setAttribute("marker-end","url(#arrowhead)");
// "class": "animpath",
// "fromto": from+" "+to,
 var svg = document.getElementById("graph0"); // this is the main SVG element from GraphViz
 svg.appendChild(newpath);
}

// function to compute the path between given endpoints [from focusmodels] ///////////////////////// fn: createPath
function createPath(startX,startY,endX,endY,offset=0,relativePath=0){
 var startPos = Array(startX,startY);
 var endPos = Array(endX,endY);
 // startPos and endPos are two-element positions
 // offset is the maximum distance from the line between them that the path should reach
 //  - use offset = -1 for a default curve
 //  - offset = 0 will be a straight line
 var debug = false;
 if (debug) console.log("Making path from "+String(startPos[0])+","+String(startPos[1])+" to "+String(endPos[0])+","+String(endPos[1]));

 if (relativePath){
  for (var d=0;d<startPos.length;d++){ // loop over each dimension
   endPos[d] -= startPos[d]; // subtract the starting coordinate to create a relative path
   startPos[d] = 0;
  }
 } else {
  // else don't subtract the starting point
 }


 // taken from https://stackoverflow.com/a/49286885
 if (offset==-1){
  // default offset is 0 but if -1 is given, make a nice "long" curve (ie. put the control point fairly far from the line between start and end)
  offset = euclideanDistance(startPos,endPos)*0.25;
 }

 var midpt = lineMidPoint(startPos,endPos);

 var p1x=startPos[0];
 var p1y=startPos[1];
 var p2x=endPos[0];
 var p2y=endPos[1];
 var mpx=midpt[0];
 var mpy=midpt[1];

 // angle of the perpendicular to line joining start and end:
 var theta = -Math.atan2(p2y - p1y, p2x - p1x) - Math.PI / 2;

 // location of control point:
 var c1x = Math.round(mpx + offset * Math.cos(theta));
 var c1y = Math.round(mpy - offset * Math.sin(theta)); // fixed
 p1x = Math.round(p1x);
 p1y = Math.round(p1y);
 p2x = Math.round(p2x);
 p2y = Math.round(p2y);

 // construct the command to draw a quadratic curve
 var thepath = "M " + p1x + " " + p1y + " Q " + c1x + " " + c1y + " " + p2x + " " + p2y;
 if (debug) console.log(" PATH: "+thepath);

 return thepath;
}

// add an SVG marker to the page to use as an arrow-head /////////////////////////////////////////// fn: createArrowMarker()
function createArrowMarker(){
 var arrowcolour = "#0003";
 // insert the marker definition:
 document.getElementById("graph0").insertAdjacentHTML('afterbegin','\
<defs>\
 <marker id="oldarrowhead" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth">\
  <path d="M0,0 L0,6 L9,3 z" fill="'+arrowcolour+'" />\
 </marker>\
 <marker id="arrowhead" markerWidth="9" markerHeight="9" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">\
  <path d="M0,0 L0,6 L9,3 z" fill="'+arrowcolour+'" />\
 </marker>\
</defs>');

// extras, not yet used:
// <marker id="axesarrow" markerWidth="10" markerHeight="10" refX="10" refY="3" orient="auto" markerUnits="strokeWidth">\
//  <path d="M0,0 L0,6 L9,3 z" fill="#f00" />\
// </marker>\
// <marker id="rayarrow" markerWidth="10" markerHeight="10" refX="2" refY="3" orient="auto" markerUnits="strokeWidth">\
//  <path d="M0,0 L3,3 L0,6" stroke-width="0.1" fill="none" stroke="#f00" />\
// </marker>\
// <path id="rayarrowbase" d="M-'+arrowSize+',0 L0,'+(arrowSize*arrowratio)+' L'+arrowSize+',0'+(filledarrows?' z" fill="'+edgeColour+'"':'"')+' stroke-width="0.5" fill="none" stroke="'+edgeColour+'" />\
// <path id="rayarrowbasefaded" d="M-'+arrowSize+',0 L0,'+(arrowSize*arrowratio)+' L'+arrowSize+',0'+(filledarrows?' z" fill="'+edgeColour+'55"':'"')+' stroke-width="0.5" fill="none" stroke="'+edgeColour+'55" />\

}

// set up the colour pickers /////////////////////////////////////////////////////////////////////// fn: setupColours
function setupColours(){
 var valency = parseInt(document.getElementById("input_valency").value);
 var thetable = document.getElementById("colourtable");
 var debug = false;

 // test that there are enough colours, but only warn and then carry on if there aren't
 if (valency>colours.length){
  console.log("WARNING: not enough colours are defined");
 }

 var tablecontent = '  <tbody>\n   <tr>\n';
 for (var i=1;i<=colours.length;i++){
  tablecontent += '    <td><span class="valencycolour" id="valcol'+i+'"></span><br/><input type="text" color="black" class="pickertheme" id="picker'+i+'"/></td>\n';
 }
 tablecontent += '   </tr>\n  </tbody>';

 if (debug) console.log("creating colour pickers");
 thetable.innerHTML = tablecontent;

 // set the colourtable "label" colours:
 // (note: this is not dynamic, since the colour-pickers are not there to change colours, but rather to specify the local actions)
 for (var i=1;i<=colours.length;i++){
  document.getElementById("valcol"+i).style.backgroundColor = colours[i-1];
  if (debug) console.log("labelling valcol"+i);
 }

}

// function to initialise the colour-pickers /////////////////////////////////////////////////////// fn: initPickers
function initPickers(){
//  initialise only, setting the options is done in setPickers()
 $(".pickertheme").spectrum({});
}

// function to match the pickers to their "labels" ///////////////////////////////////////////////// fn: setPickers
function setPickers(){
 for (i=1;i<=colours.length;i++){
  var pickername = "picker"+i;
  $("#"+pickername).spectrum({
   color: colours[i-1],
   preferredFormat: "hex3",
   clickoutFiresChange: "true",
   showPalette: true,
   showPaletteOnly: true,
   palette: colours,
//   palette: [['red'],['black'],['white']]
  });
 }
}

// function to add stylings to the SVG objects ///////////////////////////////////////////////////// fn: decorateNodes
function decorateNodes(doAutomorphism=false){
 // remove old decorations
 var old = document.getElementsByClassName("referenceNode");
 for (var j=0;j<old.length;j++) old[j].classList.remove("referenceNode");
 var old = document.getElementsByClassName("destinationNode");
 for (var j=0;j<old.length;j++) old[j].classList.remove("destinationNode");
 var oldarrow = document.getElementById("thearrow");
 if (oldarrow!=null) oldarrow.remove();

 // apply the reference and destination node classes
 if (!doAutomorphism){
  var fromNode = findSVGNode(labelNode(autoFrom));
  var toNode = findSVGNode(labelNode(autoTo));
  if (fromNode != null) document.getElementById(fromNode).classList.add("referenceNode");
  if (toNode != null) document.getElementById(toNode).classList.add("destinationNode");
  if (fromNode!=null && toNode!=null){
   addArrow(fromstring,tostring);
  }
 }

 // add classes depending on the radius of each node (ie. the distance it has moved)
 rclasses = [];
 var allnodes = document.getElementsByTagName("g");
 for (var i=0;i<allnodes.length;i++){
  if (allnodes[i].classList.contains("node")){ // only want nodes (not edges)
   var rr = parseFloat(allnodes[i].querySelector("ellipse").attributes.rx.nodeValue); // get the radius of this node's ellipse
   allnodes[i].classList.add("radius"+rr);
   console.log("ADDING RADIUS CLASS radius"+rr+" TO "+allnodes[i].id);
   if (rclasses.indexOf("radius"+rr)==-1) rclasses.push("radius"+rr);
  }
 }

 // give the SVG graph an id
 var thesvg = document.getElementsByTagName("svg");
 if (thesvg.length) thesvg[0].id = "thesvg";

 // move the SVG to the centre of the graph box:
 if (thesvg.length){
  var thegraph = document.getElementById("thegraph");
  var thepadding = parseInt(window.getComputedStyle(thegraph)["padding-top"]);
  var themargin = parseInt(window.getComputedStyle(thegraph)["margin-top"]);
  var theheight = thegraph.clientHeight;
  var thesvgheight = thesvg[0].clientHeight;
  thesvg[0].style.top = parseFloat((theheight-thepadding-themargin-thesvgheight)/2)+"px"
 }
 // add a class to the SVG indicating whether it is the post-automorphism graph
 if (doAutomorphism) document.getElementsByTagName("svg")[0].classList.add("autoGraph");
}

// show/hide labels on the SVG graph /////////////////////////////////////////////////////// fn: toggleLabels
function toggleLabels(){
 var L=document.querySelectorAll(Node='text');
 for(var i=0;i<L.length;i++){
  if (L[i].style.display=="none"){
   L[i].style.display="";
  } else {
   L[i].style.display="none";
  }
 }
}

setupColours();
initPickers();
clearAutomorphism();
setPickers();
initDrag();
setOutputValues();

</script>

</body>
</html>
