<!DOCTYPE html>
<head>
 <meta charset="utf-8">
 <title>Automorphism</title>
 <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans|Open+Sans+Condensed:Light&display=swap">
 <style>
  #theoutput {
   width: 45vw;
   clear: both;
   float: left;
   border: 1px solid red;
   padding: 5px;
   font-family: monospace, monospace;
   font-size: 8px;
  }
  #theinput {
   float: left;
   padding: 10px;
  }
  #thegraph {
   width: 45vw;
   height: 45vw; /* ie. square */
   border: 1px solid green;
   padding: 5px;
   font-family: monospace, monospace;
   float: left;
  }
  .red {
   color: red;
  }
  .toobig {
   color: yellow;
   background-color: red;
  }
  form {
   margin: 10px;
  }
  label {
   display: inline-block;
   width: 60px;
   vertical-align: middle;
  }
  input[type=range] {
   vertical-align: middle;
   margin: 4px;
  }
  input[type=text] {
   margin: 4px;
  }
  button {
   border-radius: 2px;
   font-size: 16px;
  }
 </style>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.18.1/cytoscape.min.js" integrity="sha512-MgZAJudXekIHKoFtEk1NUwpSSCDt6JlfkUdwgX/1ustAyJltGO82ayHPOyK31xy9q84nGecgtF+D9hdm2OZldg==" crossorigin="anonymous"></script>
 <script src="https://cytoscape.org/cytoscape.js-euler/cytoscape-euler.js"></script>
</head>
<body onload="manageControls();">

<form id="theinput" method="POST" oninput="manageControls();">
<!--
  <label for="xinput_valency">Valency:</label><input type="text" id="input_valency"  onchange="document.getElementById('gvbutton').setAttribute('disabled','true');" value="3" size="20" maxlength="20"/><br/>
  <label for="xinput_maxdepth">Depth:</label><input type="text" id="input_maxdepth" onchange="document.getElementById('gvbutton').setAttribute('disabled','true');" value="3" size="20" maxlength="20"/><br/>
-->
  <label for="input_valency">Valency:</label><input type="range" id="input_valency" value="3" min="2" max="10" /> <output id="output_valency"></output><br/>
  <label for="input_maxdepth">Depth:</label><input type="range" id="input_maxdepth" value="3" min="0" max="8" /> <output id="output_maxdepth"></output><br/>
  <label for="output_Nnodes">Nodes:</label><output id="output_Nnodes"></output><br/>
  <br/>

  <button onclick="run();return false;">Run</button>
  <button onclick="copy('theoutput');return false;">Copy Output</button>
  <button id="gvbutton" disabled="true" onclick="window.open(makeGraphVizLink(G),'_blank');return false;" title="Opens in new tab/window">GraphViz</button>

  <select id="input_layout" onchange="run2();return false;">
   <option value="none">none</option>
   <option value="null">null</option>
   <option value="grid" selected>grid</option>
   <option value="random">random</option>
   <option value="cose">cose</option>
<!--   <option value="euler">euler</option>-->
  </select>
  <br/>
</form>

<div id="theoutput" title="Click to copy">Dot code will be shown here. GraphViz button opens the result in a new tab/window.</div>
<svg id="notthegraph"><g/></svg>
<div id="thegraph"></div>

<script>
 // set up some constants
 const Pi = Math.acos(-1);
// const thelabels = "abcdefghijklmnopqrstuvwxyz0123456789".split(""); // used for dot language output
 const thelabels = "rbgmckyabcdefghijklmnopqrstuvwxyz0123456789".split(""); // used for dot language output [using first three colour initials]
 const EDGESEP = " -- "; // dot language output separator (-- or ->)
 const ROOTNODE = "\u{d8}"; // capital-O-with-stroke symbol https://graphemica.com/%C3%98
// const ROOTNODE = "0";


// function to provide label characters //////////////////////////////////////////////////////////// fn:label
function label(n){
 return (n>=0 & n<thelabels.length ? thelabels[n] : "X"); // return "X" if n is out of range
}

// function to label a whole node ////////////////////////////////////////////////////////////////// fn: labelNode
function labelNode(node){
 if (node!=null){
  thelabel = node.map(label).join("");
  if (thelabel.length==0) thelabel = ROOTNODE;
  return thelabel;
 } else {
  return null;
 }
}

// function to turn the nodes and edges into a cytoscape data structure //////////////////////////// fn: mkcyto
function mkcyto(nodes,edges,uselabels=false,refNode=[],destNode=[],refNeigh=[],destNeigh=[],localActionNeigh=[]){
 var thedata = [];
 for (var i=0;i<nodes.length;i++){
  var thisnode = {
   "data": {
    "id": "node"+i,
    "label": labelNode(nodes[i]),
    "weight": 4
   },
   "position": {
// omit pre-computed positions for now
//    "x": 150,
//    "y": 45
   },
   "group": "nodes",
   "removed": false,
   "selected": false,
   "selectable": true,
   "locked": false,
   "grabbable": true,
   "classes": ""
  };
  thedata.push(thisnode);
 }


 for (var i=0;i<edges.length;i++){
  var from = nodes[edges[i][0]].join("");
  var to = nodes[edges[i][1]].join("");
  var thiscolour = colours[to[to.length-1]];

  var thisedge = {
   "data": {
    "id": "edge"+i,
    "weight": 12,
    "source": "node"+edges[i][0],
    "target": "node"+edges[i][1]
   },
   "position": {},
   "group": "edges",
   "removed": false,
   "selected": false,
   "selectable": true,
   "locked": false,
   "grabbable": true,
   "css": {"line-color": thiscolour},
//   "target-arrow-shape": "none",
   "classes": ""
   };
   thedata.push(thisedge);
  };


 // finished, return the object containing the nodes and edges:
 return thedata;
}


// function to turn nodes and edges into dot output //////////////////////////////////////////////// fn: mkdot
function mkdot(nodes,edges,uselabels=false,refNode=[],destNode=[],refNeigh=[],destNeigh=[],localActionNeigh=[]){
 var maxdepth = parseInt(document.getElementById("input_maxdepth").value);
 var valency = parseInt(document.getElementById("input_valency").value);

 colours=["red","blue","green","magenta","cyan","black","yellow"];

 var thisgraph = 'graph {\n';
 thisgraph += '\t// valency = '+valency+', depth = '+maxdepth+'\n\n';
 thisgraph += '\tedge [penwidth=1, color=black]\n';
 thisgraph += '\tnode [shape=circle, color=black, style=filled, fillcolor="#88888844", fontsize=14, fixedsize=true, fontcolor="#aaaaaa"]\n'
 thisgraph += '\tranksep=2\n';
 thisgraph += '\n\t// EDGES\n';
 for (var i=0;i<theedges.length;i++){
  var from = thenodes[theedges[i][0]].join("");
  var to = thenodes[theedges[i][1]].join("");
  if (uselabels){
   var fromLabel = labelNode(thenodes[theedges[i][0]]);
   var toLabel = labelNode(thenodes[theedges[i][1]]);
  } else {
   var fromLabel = from;
   var toLabel = to;
  }
  if (fromLabel.length==0) fromLabel = ROOTNODE;
  if (toLabel.length==0) toLabel = ROOTNODE;
  thiscolour = colours[to[to.length-1]]
//  thisgraph += '\t' + fromLabel + EDGESEP + toLabel + ' [color='+thiscolour+']\n';
  thisgraph += '\t' + fromLabel + EDGESEP + toLabel + '\n';
 }

 if (refNeigh.length==destNeigh.length & refNeigh.length==localActionNeigh.length){
  // draw dashed edges showing the new edges
  // insert a comment for blanking out all of the unspecified (in the automorphism) nodes (just in case it is wanted)
  thisgraph += '\n\t// NO LABELS? Uncomment this line:\n';
  thisgraph += '//\t';
  for (var i=0;i<nodes.length;i++){
   thisgraph += labelNode(nodes[i])+',';
  }
  thisgraph = thisgraph.slice(0,thisgraph.length-1); // remove trailing comma
  thisgraph += ' [label=""]\n';

  thisgraph += '\n\t// AUTOMORPHISM\n';
  thisgraph += '\tedge [penwidth=5]\n';

  for (var i=0;i<localActionNeigh.length;i++){

   /* --- start colour */
   if (destNeigh[i].length<destNode.length){
    // "parent" neighbour, use the last entry of the reference node for the colour:
    thiscolour = colours[destNode[destNode.length-1]];
   } else {
    // "regular" neighbour, use the last entry for the colour:
    thiscolour = colours[destNeigh[i][destNeigh[i].length-1]];
   }
   /* --- end colour */

   thisgraph += '\t'+labelNode(destNode) + EDGESEP + labelNode(localActionNeigh[i]) + ' [style=dashed, color='+thiscolour+']\n';
  }
  // highlight and relabel the reference node and its neighbours
  thisgraph += '\t'+labelNode(refNode)+' [fillcolor=green, fontcolor=black, penwidth=5, label="'+labelNode(refNode)+'"]\n';
  for (var i=0;i<refNeigh.length;i++){
   thisgraph += '\t'+labelNode(refNeigh[i])+' [fillcolor=green, fontcolor=black, label="'+labelNode(refNeigh[i])+'"]\n';
  }
  // highlight and relabel the destination nodes
  thisgraph += '\t'+labelNode(destNode)+' [fillcolor=yellow, fontcolor=black, penwidth=5, label="'+labelNode(destNode)+'\\n'+labelNode(refNode)+'"]\n';
  for (var i=0;i<localActionNeigh.length;i++){
   thisgraph += '\t'+labelNode(localActionNeigh[i])+' [fillcolor=yellow, fontcolor=black, label="'+labelNode(localActionNeigh[i])+'\\n'+labelNode(refNeigh[i])+'"]\n';
  }

 } else {
  // error if the reference and destination neighbour lists are different lengths
  console.log("[mkdot] Wrong length");
 }

 thisgraph += '}\n';
 return thisgraph;
}


function run2(){
 /* good animation example: :https://cytoscape.org/cytoscape.js-cose-bilkent/ */
 
 // skip this if the Cytoscape layout is "none":
 if (document.getElementById("input_layout").value=="none"){
  console.log("Skipping Cytoscape graph");
 } else {
  graphData = mkcyto(thenodes,theedges,true,autoFrom,autoTo,autoNeighbours,toNeighbours,permNeighbours);
  var cy=cytoscape({
   container: document.getElementById("thegraph"),
   elements: graphData,

   style: [ // the stylesheet for the graph
     {
       selector: "node",
       style: {
         "background-color": "#666",
         "label": "data(label)" // was "data(id)"
       }
     },

     {
       selector: "edge",
       style: {
//         "width": 3,
//         "line-color": "#ccc",
//         "target-arrow-color": "#ccc",
//         "target-arrow-shape": "triangle",
         "curve-style": "bezier"
       }
     }
   ],

   layout: {name: document.getElementById("input_layout").value},

  });
 } // end if "none" loop
}

function run(){
// var maxdepth = 3;
// valency = 3;
 // use the form values:
 var maxdepth = parseInt(document.getElementById("input_maxdepth").value);
 var valency = parseInt(document.getElementById("input_valency").value);
 var valencyList = [];
 for (var v=0;v<valency;v++){
  valencyList.push(v);
 }

 // initialise
 thenodes = [];       // list of nodes by address
 thenodes[0] = [];    // root node
 theedges = [];       // pair-wise edges, using indices
 thenodeindex = [];   // associative array, index by node address
 thenewnodes = [];    // list of nodes by address post-automorphism
 thelocalaction = []; // list of automorphism permutation at each node (local action)
 autoprogress = [];   // list of flags indicating which nodes have been determined under the automorphism

 // loop over all nodes and add children to those at the (current) maximum depth
 for (var d=0;d<maxdepth;d++){
  for (var i=0;i<thenodes.length;i++){
   if (thenodes[i].length==d){
    for (var v=0;v<valency;v++){
     if (thenodes[i][thenodes[i].length-1]!=v){ // but only add this node if it really exists (ie. not doubling back on the path)
      thenodes[thenodes.length] = thenodes[i].concat(v);
      // store the index of each node address as well (to aid searching)
      thenodeindex[thenodes[thenodes.length-1].toString()] = thenodes.length-1;
      // and add an edge at the same time
      theedges.push([i,thenodes.length-1]);
     }
    }
   }
  }
 }

 // initialise the post-automorphism nodes
 for (var i=0;i<thenodes.length;i++){
  thenewnodes[i] = null; // Note: empty value is reserved for the root node
  autoprogress[i] = false;
 }

/*
 // now define the automorphism: [THESE WILL COME FROM USER INPUT]
 if (0){
  autoFrom = [0,1,2];
  autoTo = [1,2];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }
 if (0){
  autoFrom = [2];
  autoTo = [1,2];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }
 if (0){
  autoFrom = [2,0,1];
  autoTo = [1,0,2];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }
 if (0){
  autoFrom = [2,1,2];
  autoTo = [1,0,2];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }
 if (0){
  autoFrom = [2,1,2,1];
  autoTo = [1,0,2];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }
 if (1){
  autoFrom = [2];
  autoTo = [1,2,1];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }
*/

 //
 // define the automorphism: [EVENTUALLY THESE WILL COME FROM USER INPUT]
 //
 autoFrom = [2];
 autoTo = [1,2,1];
 localActionPermutation = permutationCyclic(valencyList,1); // for example


 // get neighbours
 autoNeighbours = findNeighbours(autoFrom,valency);  // these nodes...
 toNeighbours = findNeighbours(autoTo,valency);     // ...map to these nodes
 permNeighbours = localAction(toNeighbours,localActionPermutation,valency);
 
 console.log("Reference node moves:");
 console.log(labelNode(autoFrom)+" --> "+labelNode(autoTo));
 console.log(" ");
 console.log("Node label --> maps to --> permutes to");
 for (var i=0;i<autoNeighbours.length;i++){
  console.log(autoNeighbours[i].map(label).toString()+"\t-->\t"+toNeighbours[i].map(label).toString()+"\t-->\t"+permNeighbours[i].map(label).toString());
 }


 // create the dot graph ////////////////////////////////////////////////////////////////////////// make the graph
// drawFrom = [autoFrom].concat(autoNeighbours);
// drawTo = [autoTo].concat(permNeighbours);
 G = mkdot(thenodes,theedges,true,autoFrom,autoTo,autoNeighbours,toNeighbours,permNeighbours);
 document.getElementById("theoutput").innerHTML = "<pre>"+G+"</pre>";
 document.getElementById("theoutput").setAttribute("data-copy-text",G); // for the clipboard
 // feed it to:
 //		https://dreampuf.github.io/GraphvizOnline/

 // turn on the GraphViz button
 if (calcSize()<=20000){
  document.getElementById("gvbutton").removeAttribute("disabled");
 }

 run2(); // draw the Cytoscape graph

 // the new approach to performing the automorphism:
 // (for now, only define the local action at the reference node)
 thenewnodes[findNode(autoTo,thenodeindex)] = autoFrom;
 thelocalaction[findNode(autoFrom,thenodeindex)] = localActionPermutation;
 processnode(autoFrom,valency);


 return 0;
} // end run()

// random integers ///////////////////////////////////////////////////////////////////////////////// fn: randomInt
function randomInt(n=1){
 return Math.floor(Math.random()*n); // random integer from the set [0, 1, ..., n-1]
}

// cyclically permute a given list (by a specified "distance") ///////////////////////////////////// fn: permutationCyclic
function permutationCyclic(list,dist=0){
 var out = Array(list.length); // initialise
 while (dist>list.length) dist-=list.length; // avoid winding
 while (dist<0) dist+=list.length; // avoid winding
 for (var i=0;i<(list.length-dist);i++) out[i]=list[i+dist]; // 0 ... dist
 for (var i=list.length-dist;i<list.length;i++) out[i]=list[i+dist-list.length]; // dist+1 ... end
 return out;
}

// randomly permute a given list /////////////////////////////////////////////////////////////////// fn: permutationRandom
function permutationRandom(list){
 var inlist = Array(list.length); // initialise
 var out = Array(list.length); // initialise
 for (var i=0;i<list.length;i++) inlist[i] = list[i]; // make a copy
 for (var i=0;i<list.length;i++) out[i] = inlist.splice(randomInt(inlist.length),1); // extract the elements in random order
 return out;
}

// test a permutation vector for legality ////////////////////////////////////////////////////////// fn: testPermuation
function testPermutation(perm,valency){
 // test for a valid permutation
 if (perm.length==valency){ // right size?
  for (var p=0;p<perm.length;p++){
   if (perm.indexOf(perm[p])!=p){ // repeated entries?
    console.log("ERROR: invalid permutation (repeated entries)");
    return false;
   }
  }
 } else {
  console.log("ERROR: permutation length ("+perm.length+") is not equal to the valency ("+valency+")");
  return false;
 }
 return true;
}

// permute a given list using the provided permutation ///////////////////////////////////////////// fn: permute
function localAction(list,perm,valency){
 // takes a list of a node's neighbours (ie. list length = valency) and permutes them

 if (testPermutation(perm,valency)){
  // legal permutation, so perform the operation
  var out = Array(list.length);
  for (var i=0;i<list.length;i++){
  // permute elements: local action (ie swap the elements of the list around with each other)
   out[i] = list[perm[i]];
//   out[perm[i]] = list[i]; // reverse of standard notation
  }
  return out;
 } else {
  return undefined;
 }
}

// find the neighbours of a given node, for a given valency //////////////////////////////////////// fn: findNeighbours
function findNeighbours(node,valency){
 neighbours = Array(valency); // initialise
 for (var v=0;v<valency;v++){
  if (v==node[node.length-1]){ // check for the "parent" node
   // add the neighbour towards the root node
   neighbours[v] = node.slice(0,node.length-1);
  } else {
   neighbours[v] = node.concat(v);
  }
 }
 return neighbours;
}

// copy the clicked object's contents ////////////////////////////////////////////////////////////// fn: copy
async function copy(targetId=null){
 // Modified from https://www.jasongaylord.com/blog/2020/05/21/copy-to-clipboard-using-javascript
 if (!navigator.clipboard){
  return;
 }

 try {
  if (targetId==null){
   target = event.srcElement;
  } else {
   target = document.getElementById(targetId);
  }
  var copy_value = target.getAttribute("data-copy-text");
  await navigator.clipboard.writeText(copy_value);
 } catch (error){
  console.error("copy failed", error);
 }
}

// create a GraphViz Online link /////////////////////////////////////////////////////////////////// fn: makeGraphVizLink
function makeGraphVizLink(G){
 return "https://dreampuf.github.io/GraphvizOnline/#"+encodeURIComponent(G);
}

// manage the control values and buttons /////////////////////////////////////////////////////////// fn: manageControls
function manageControls(){
 document.getElementById("gvbutton").setAttribute("disabled","true");
 document.getElementById("output_valency").value = parseInt(document.getElementById("input_valency").value);
 document.getElementById("output_maxdepth").value = parseInt(document.getElementById("input_maxdepth").value);
 document.getElementById("output_Nnodes").value = calcSize();

 document.getElementById("output_Nnodes").classList.remove("toobig")
 document.getElementById("gvbutton").classList.remove("toobig")
 document.getElementById("output_Nnodes").classList.remove("red","toobig")
 document.getElementById("gvbutton").classList.remove("toobig")

 if (calcSize()>20000){
  document.getElementById("gvbutton").setAttribute("disabled","true");
  document.getElementById("output_Nnodes").classList.add("toobig")
  document.getElementById("gvbutton").classList.add("toobig")
 } else if (calcSize()>5000){
  document.getElementById("output_Nnodes").classList.add("red")
 }
}

// how big is the graph? /////////////////////////////////////////////////////////////////////////// fn: calcSize
function calcSize(valency=null,maxdepth=null){
 // get the valency and maxdepth if they were not provided:
 if (valency==null) valency = parseInt(document.getElementById("input_valency").value);
 if (maxdepth==null) maxdepth = parseInt(document.getElementById("input_maxdepth").value);
 var Nnodes = 0;
 for (var d=0;d<=maxdepth;d++){
  Nnodes += Math.pow(valency,d); // valency^d nodes at each depth
 }
 return Nnodes;
}


// process the automorphism //////////////////////////////////////////////////////////////////////// fn: processnode
function processnode(v,valency,debug=false){
 console.log("Processing node "+labelNode(v)); // +"                                   ie. "+v.toString()+" (valency="+valency+")");
 var indx = findNode(v,thenodeindex);
 // has this node been drawn within the current extent of the graph?
 if (indx==undefined){
  console.log("    ... stopping at "+labelNode(v)+" [node not drawn]"); // v is off the drawn graph
 } else {
  if (autoprogress[indx]){
   console.log("    ... already done node "+labelNode(v));
  } else {
   autoprogress[indx] = true;

   // 1. retrieve the local action, f_v, at this node
   //    -- user-given or
   //    -- (constrained) random or
   //    -- same as at the reference node
   // [EVENTUALLY THESE WILL COME FROM USER INPUT]
/*
   if (indx<10){
    thelocalaction[indx] = localActionPermutation; // for now, use the reference node's local action everywhere
   } else {
    thelocalaction[indx] = null; // don't define a local action on some nodes, so that their post-automorphism neighbours remain undefined
   }
*/

   if (thelocalaction[indx]==null){
    console.log("    ... no local action defined at "+labelNode(v));
   } else {
    // 2. find this node's neighbours, vi
    var vi = findNeighbours(v,valency);
    if (debug) console.log(" The neighbours of "+labelNode(v)+" are "+vi.map(labelNode).toString());

    // 3. permute them according to the local action to give vif (remember that localAction() takes a list of nodes as its input)
    var vif = localAction(vi,thelocalaction[indx],valency);

    // 3. for each neighbour:
    for (var i=0;i<vi.length;i++){
     if (debug) console.log("  Working on "+labelNode(v)+" neighbour "+labelNode(vi[i])+" -> "+labelNode(vif[i]));
     // find the index of this node's destination
     destindx = findNode(vif[i],thenodeindex);

     // can we draw this destination node?
     if (destindx==undefined){
      if (debug) console.log("   "+labelNode(vi[i])+" node destination "+labelNode(vif[i])+" is outside the drawn graph ");
      console.log("    ... skipping "+labelNode(vif[i])+" [destination not drawn]"); // v is off the drawn graph
     } else {
      if (1|debug) console.log("                                                            "+labelNode(vi[i])+" node destination "+labelNode(vif[i])+" is at node "+destindx);
      thenewnodes[destindx] = vi[i];
      // now work on this neighbour's neighbours
      if (debug) console.log("Calling processnode(["+vi[i]+"],"+valency+"), ie. processnode(["+labelNode(vi[i])+"],"+valency+")");
      processnode(vi[i],valency);
     }
    }
   }
  }
 }
 return 0;
}

// find the index of a node by its address ///////////////////////////////////////////////////////// fn: findNode
function findNode(v,nodeindex){
 if (v.length){
  return nodeindex[v];
 } else {
  return 0; // the root node is always the first node
 }
}

</script>

</body>
</html>
