<!DOCTYPE html>
<head>
 <meta charset="utf-8">
 <title>Automorphism</title>
 <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans|Open+Sans+Condensed:Light&display=swap">
 <link rel="stylesheet" href="graphControls.css">
 <style>
  html {
   overflow: hidden;
   background: #333;
/*   font-family: "Open Sans", sans-serif;*/
   font-family: "Open Sans Condensed", sans-serif;
  }
  #graphControls {
   color: #600;
  }
  #thegraph {
   border: 2px solid #446;
   display: block;
   margin: 0 auto;
   box-shadow: inset 3px 3px 3px #bbb;
   background-color: #777;
   xxxbackground-color: #f5f5f5;

   /* copied from graphControls.css: */
   border: 2px solid black;
   box-shadow: inset -4px -4px 6px #666, -3px 3px 5px #222;
   border-radius: 10px;
  }
  #dotContainer {
   position: relative;
   xxxwidth: 70vh;
   height: 70vh;
   width: 45vw;
   float: left;
   margin-right: 20px;
  }
  #dotContainer > * {
   position: absolute;
  }
  #dotContainer > button {
   font-size:12px;
   top: 12px;
   right: -10px;
   right: 5px;
  }
  #theoutput {
   position: absolute;
   xxxwidth: 70vh;
   xxxheight: 70vh;
   xxxclear: both;
   xxxfloat: left;
   width: 100%;
   height: 100%;
   border: 1px solid red;
   padding: 5px;
   margin: 5px;
   box-sizing: content-box;
   font-family: monospace, monospace;
   font-size: 12px;
   overflow: auto;
   color: yellow;
  }
  #thegraph {
   xxxwidth: 70vh;
   height: 70vh; /* ie. square */
   width: 45vw;
   padding: 5px;
   margin: 5px;
   box-sizing: content-box;
   float: left;
  }
  #thegraph svg {
   max-height: 100%;
   max-width: 100%;
  }
  #thegraph > svg > g > polygon {
   display: none; /* hide the default background object on the GraphViz graph */
  }
  .red {
   color: red;
  }
  .toobig {
   color: yellow;
   background-color: red;
  }
  form {
   margin: 10px;
  }
  label {
   display: inline-block;
   width: 180px;
   font-size: 12px;
   text-align: right;
   margin-right: 10px;
  }
  input[type=range] {
   vertical-align: middle;
   margin: 4px;
  }
  input[type=checkbox] {
   vertical-align: middle;
  }
  input[type=text] {
   margin: 4px;
  }
  button {
   border-radius: 2px;
   font-size: 16px;
  }
 </style>
 <script src="https://cdn.jsdelivr.net/npm/@hpcc-js/wasm/dist/index.min.js"></script>
 <script>
  var hpccWasm = window["@hpcc-js/wasm"];
 </script>

</head>
<body onload="setOutputValues()">

 <div id="graphControls">
  <div class="onecontrol">Valency:<br/>
   <input type="range" id="input_valency" value="3" min="2" max="10" oninput="setOutputValues();"/>
   <output id="output_valency"></output>
  </div>
  <div class="onecontrol">Depth:<br/>
   <input type="range" id="input_maxdepth" value="3" min="0" max="10" oninput="setOutputValues();"/>
   <output id="output_maxdepth"></output>
  </div>

  <div class="onecontrol">Nodes:<br/>
   <output id="output_Nnodes"></output>
  </div>

  <div class="onecontrol">Original nodes only:<br/>
   <label class="switch">
   <input type="checkbox" checked id="input_extent" />
   <span class="slider round"></span>
   </label>
  </div>
  <div class="onecontrol">Label nodes:<br/>
   <label class="switch">
   <input type="checkbox" checked id="input_labels" />
   <span class="slider round"></span>
   </label>
  </div>
  <div class="onecontrol">Original labels too:<br/>
   <label class="switch">
   <input type="checkbox" id="input_xlabels" />
   <span class="slider round"></span>
   </label>
  </div>
  <div class="onecontrol">Show distances:<br/>
   <label class="switch">
   <input type="checkbox" id="input_showdists" />
   <span class="slider round"></span>
   </label>
  </div>
  <div class="onecontrol">Size nodes by distance:<br/>
   <label class="switch">
   <input type="checkbox" checked id="input_nodesize" />
   <span class="slider round"></span>
   </label>
  </div>

  <div class="onecontrol controlwrapper">
   <span class="wrappertext">Engine</span><br/>
   <select id="input_layout">
    <option value="none">none</option>
    <option value="circo">circo</option>
    <option value="dot">dot</option>
    <option value="fdp">fdp</option>
    <option value="sfdp">sfdp</option>
    <option value="neato" selected>neato</option>
    <option value="osage">osage</option>
    <option value="patchwork">patchwork</option>
    <option value="twopi">twopi</option>
   </select>
  </div>

  <div class="onecontrol controlwrapper">
   <span class="wrappertext">Format</span><br/>
   <select id="input_format">
    <option value="dot" disabled>dot</option>
    <option value="svg" selected>svg</option>
   </select>
  </div>

  <button class="onecontrol" style="font-size:2em;" onclick="run();">Run</button>
<!--  <button class="onecontrol" style="font-size:2em;" onclick="copy('theoutput');">Copy Dot</button>-->
 </div>

<div id="dotContainer">
 <div id="theoutput">Dot code will be shown here</div>
 <button onclick="copy('theoutput');">Copy</button>
</div>
<div id="thegraph"></div>


<script>
 // set up some constants
 const Pi = Math.acos(-1);
 const thelabels = "rbgmckyabcdefghijklmnopqrstuvwxyz0123456789".split(""); // used for dot language output [using first three colour initials]
 const EDGESEP = " -- "; // dot language output separator (-- or ->)
 const ROOTNODE = "\u{d8}"; // capital-O-with-stroke symbol https://graphemica.com/%C3%98
// const colours=["red","blue","green","magenta","cyan","black","yellow"];
 const colours=["#ff0000","#0000ff","#00ff00","#ff00ff","#00ffff","#000000","#ffff00"];

 // colour set-up of nodes, edges and labels:
 const thenodecolour = 'orange';
 const theedgecolour = 'black'; // currently a fall-back (each edge's colour is over-ridden individually)
 const thefadednodecolour = '#eaeaea22';
 const thelabelcolour = '#ff0000';
 const thefadedlabelcolour = '#aaaaaa';
 const thefadeopacity = '77'; // 2-digit hex code
 const thereferencenodecolour = 'yellow';
 const thereferencelabelcolour = 'black';

// function to provide label characters //////////////////////////////////////////////////////////// fn:label
function label(n){
 return (n>=0 & n<thelabels.length ? thelabels[n] : "X"); // return "X" if n is out of range
}

// function to label a whole node ////////////////////////////////////////////////////////////////// fn: labelNode
function labelNode(node){
 if (node!=null){
  thelabel = node.map(label).join("");
  if (thelabel.length==0) thelabel = ROOTNODE;
  return thelabel;
 } else {
  return null;
 }
}

// function to turn nodes and edges into dot output //////////////////////////////////////////////// fn: mkdot
function mkdot(){
 var maxdepth = parseInt(document.getElementById("input_maxdepth").value);
 var valency = parseInt(document.getElementById("input_valency").value);

 var showlabels = document.getElementById("input_labels").checked;
 var showaddresses = true;
 var showoriglabels = document.getElementById("input_xlabels").checked;
 var showdists = document.getElementById("input_showdists").checked;
 var sizebydist = document.getElementById("input_nodesize").checked;


 var thisgraph = 'graph {\n';
 thisgraph += '\t// valency = '+valency+', depth = '+maxdepth+'\n\n';
 thisgraph += '\tedge [penwidth=1, color='+theedgecolour+']\n';
 thisgraph += '\tnode [shape=circle, color=none, style=filled, fillcolor="'+thefadednodecolour+'", fontsize=14, fixedsize=true, fontcolor="'+thefadedlabelcolour+'"]\n';
 thisgraph += '\tranksep=2\n';
 thisgraph += '\n\t// EDGES\n';
 for (var i=0;i<theedges.length;i++){
  var from = thenodes[theedges[i][0]].join("");
  var to = thenodes[theedges[i][1]].join("");
  if (showaddresses){
   var fromLabel = labelNode(thenewnodes[theedges[i][0]]);
   var toLabel = labelNode(thenewnodes[theedges[i][1]]);
  } else {
   var fromLabel = from;
   var toLabel = to;
   if (fromLabel.length==0) fromLabel = ROOTNODE;
   if (toLabel.length==0) toLabel = ROOTNODE;
  }

  // some labels might be missing post-automorphism, so use the index instead
  var fadeedge = false;
  if (fromLabel==null || toLabel==null) fadeedge = true;
  if (fromLabel==null) fromLabel = theedges[i][0];
  if (toLabel==null) toLabel = theedges[i][1];

  thiscolour = colours[to[to.length-1]]
//  thisgraph += '\t' + fromLabel + EDGESEP + toLabel + '\n'; // no coloured edges (all black)
//  thisgraph += '\t' + fromLabel + EDGESEP + toLabel + ' [color='+thiscolour+']\n'; // coloured edges
  thisgraph += '\t' + fromLabel + EDGESEP + toLabel + ' [color="'+thiscolour+(fadeedge?thefadeopacity:'')+'"]\n'; // coloured edges, faded if either end is not defined in the automorphism
 }

 thisgraph += '\n\t// POST-AUTOMORPHISM NODES\n';
 for (var i=0;i<thenewnodes.length;i++){
  var thislabel = labelNode(thenewnodes[i]);
  var nodecolour = thenodecolour;
  var fontcolour = thelabelcolour;
  var xlabel = labelNode(thenodes[i]);
  var thisradius = 0.1;
  var showdist = null;

  // if there is an entry in thenewnodes, set the properties of the node
  if (thislabel!=null){
   // distinguish the reference node:
   if (labelNode(thenewnodes[i])==labelNode(autoFrom)){
    nodecolour = thereferencenodecolour;
    fontcolour = thereferencelabelcolour;
   }

   if (autodistance[thenewnodes[i].toString()]!=undefined){
    thisradius = 1/autodistance[thenewnodes[i].toString()];
    showdist = autodistance[thenewnodes[i].toString()];
   } else { // try the old label instead?
    if (autodistance[thenodes[i].toString()]!=undefined){
     thisradius = 5/autodistance[thenodes[i].toString()];
     showdist = autodistance[thenodes[i].toString()];
    } else {
     console.log("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ undefined distance for node "+thenodes[i].toString());
    }
   }
   thisgraph += '\t' + thislabel + ' ['+(showlabels?'':'label="", ')+'fillcolor=' + nodecolour + ', color=black, fontcolor="' + fontcolour + '", '+(showoriglabels?'xlabel="'+xlabel+((showdists&(showdist!=null))?' ('+showdist+')", ':'" '):((showdists&(showdist!=null))?'label="'+thislabel+' ('+showdist+')", ':'')) + ((sizebydist&(showdist!=null))?'width='+thisradius.toFixed(4):'') + ']\n';
  } else { // otherwise, just add the external label
   thislabel = i;
   xlabel = labelNode(thenodes[i]);
   thisgraph += '\t' + thislabel + ' ['+(showlabels?(showoriglabels?'':((showdists&(showdist!=null))?'label="'+thislabel+' ('+showdist+')"':'')):'label="", ')+(showoriglabels?'xlabel='+xlabel+', ':'') + ']\n';
  }
 }

 thisgraph += '}\n';
 return thisgraph;
}


function drawGraph(){
 var useformat = document.getElementById("input_format").value;
 var useengine = document.getElementById("input_layout").value;

 // skip this if the GraphViz engine is "none":
 if (useengine=="none"){
  console.log("Skipping GraphViz graph");
 } else {
  graphData = mkdot();

  hpccWasm.graphviz.layout(graphData, useformat, useengine, ).then(svg => {
   const div = document.getElementById("thegraph");
   div.innerHTML = svg;
  });

 } // end if "none" loop
}

function run(){
 // get values from the user controls:
 var maxdepth = parseInt(document.getElementById("input_maxdepth").value);
 var valency = parseInt(document.getElementById("input_valency").value);
 var valencyList = [];
 for (var v=0;v<valency;v++){
  valencyList.push(v);
 }

 // initialise
 thenodes = [];        // list of nodes by address
 thenodes[0] = [];     // root node
 theedges = [];        // pair-wise edges, using indices
 thenodeindex = [];    // associative array, index by node address
 thenewnodes = [];     // list of nodes by address post-automorphism
 thenewnodeindex = []; // associative array, index by node address, for the post-automorphism graph
 thelocalaction = [];  // list of automorphism permutation at each node (local action)
 autoprogress = [];    // list of flags indicating which nodes have been determined (processed) under the automorphism
 autodistance = [];    // compute how far each node has moved

 thenodeindex["ROOT"] = 0;

 // loop over all nodes and add children to those at the (current) maximum depth
 for (var d=0;d<maxdepth;d++){
  for (var i=0;i<thenodes.length;i++){
   if (thenodes[i].length==d){
    for (var v=0;v<valency;v++){
     if (thenodes[i][thenodes[i].length-1]!=v){ // but only add this node if it really exists (ie. not doubling back on the path)
      thenodes[thenodes.length] = thenodes[i].concat(v);
      // store the index of each node address as well (to aid searching)
      thenodeindex[thenodes[thenodes.length-1].toString()] = thenodes.length-1; // at this point, this is never the root node (we started there, and are adding children)
      // and add an edge at the same time
      theedges.push([i,thenodes.length-1]);
     }
    }
   }
  }
 }

 // initialise the post-automorphism nodes
 for (var i=0;i<thenodes.length;i++){
  thenewnodes[i] = null; // Note: empty value is reserved for the root node, so use null for unspecified nodes
 }


 //
 // define the automorphism: [EVENTUALLY THIS WILL COME FROM USER INPUT]
 //
 autoFrom = [0]; // for example
 autoTo = [1]; // for example
 localActionPermutation = permutationCyclic(valencyList,1); // for example

 // the new approach to performing the automorphism:
 // (for now, only define the local action at the reference node)
 thenewnodes[findNode(autoTo,thenodeindex)] = autoFrom; // set the label at the destination
 thenewnodeindex[autoFrom.toString()] = findNode(autoTo,thenodeindex); // put the destination node index into the look-up table of nodes
 thelocalaction[findNode(autoFrom,thenodeindex)] = localActionPermutation;

 // carry out the automorphism:
 processnode(autoFrom,valency);

 // create and draw the graph
 drawGraph();

 // create the dot graph ////////////////////////////////////////////////////////////////////////// make the graph
 G = mkdot();
 document.getElementById("theoutput").innerHTML = "<pre>"+G+"</pre>";
 document.getElementById("theoutput").setAttribute("data-copy-text",G); // for the clipboard
 // alternatively, feed it to:
 //		https://dreampuf.github.io/GraphvizOnline/

 return 0;
} // end run()

// random integers ///////////////////////////////////////////////////////////////////////////////// fn: randomInt
function randomInt(n=1){
 return Math.floor(Math.random()*n); // random integer from the set [0, 1, ..., n-1]
}

// cyclically permute a given list (by a specified "distance") ///////////////////////////////////// fn: permutationCyclic
function permutationCyclic(list,dist=0){
 var out = Array(list.length); // initialise
 while (dist>list.length) dist-=list.length; // avoid winding
 while (dist<0) dist+=list.length; // avoid winding
 for (var i=0;i<(list.length-dist);i++) out[i]=list[i+dist]; // 0 ... dist
 for (var i=list.length-dist;i<list.length;i++) out[i]=list[i+dist-list.length]; // dist+1 ... end
 return out;
}

// randomly permute a given list /////////////////////////////////////////////////////////////////// fn: permutationRandom
function permutationRandom(list){
 var inlist = Array(list.length); // initialise
 var out = Array(list.length); // initialise
 for (var i=0;i<list.length;i++) inlist[i] = list[i]; // make a copy
 for (var i=0;i<list.length;i++) out[i] = inlist.splice(randomInt(inlist.length),1); // extract the elements in random order
 return out;
}

// test a permutation vector for legality ////////////////////////////////////////////////////////// fn: testPermuation
function testPermutation(perm,valency){
 // test for a valid permutation
 if (perm.length==valency){ // right size?
  for (var p=0;p<perm.length;p++){
   if (perm.indexOf(perm[p])!=p){ // repeated entries?
    console.log("ERROR: invalid permutation (repeated entries)");
    return false;
   }
  }
 } else {
  console.log("ERROR: permutation length ("+perm.length+") is not equal to the valency ("+valency+")");
  return false;
 }
 return true;
}

// permute a given list using the provided permutation ///////////////////////////////////////////// fn: permute
function localAction(list,perm,valency){
 // takes a list of a node's neighbours (ie. list length = valency) and permutes them

 if (testPermutation(perm,valency)){
  // legal permutation, so perform the operation
  var out = Array(list.length);
  for (var i=0;i<list.length;i++){
  // permute elements: local action (ie swap the elements of the list around with each other)
   out[i] = list[perm[i]];
//   out[perm[i]] = list[i]; // reverse of standard notation
  }
  return out;
 } else {
  return undefined;
 }
}

// find the neighbours of a given node, for a given valency //////////////////////////////////////// fn: findNeighbours
function findNeighbours(node,valency){
 neighbours = Array(valency); // initialise
 for (var v=0;v<valency;v++){
  if (v==node[node.length-1]){ // check for the "parent" node
   // add the neighbour towards the root node
   neighbours[v] = node.slice(0,node.length-1);
  } else {
   neighbours[v] = node.concat(v);
  }
 }
 return neighbours;
}

// copy the clicked object's contents ////////////////////////////////////////////////////////////// fn: copy
async function copy(targetId=null){
 // Modified from https://www.jasongaylord.com/blog/2020/05/21/copy-to-clipboard-using-javascript
 if (!navigator.clipboard){
  return;
 }

 try {
  if (targetId==null){
   target = event.srcElement;
  } else {
   target = document.getElementById(targetId);
  }
  var copy_value = target.getAttribute("data-copy-text");
  await navigator.clipboard.writeText(copy_value);
 } catch (error){
  console.error("copy failed", error);
 }
}

// create a GraphViz Online link /////////////////////////////////////////////////////////////////// fn: makeGraphVizLink
/*
//function makeGraphVizLink(G){
 return "https://dreampuf.github.io/GraphvizOnline/#"+encodeURIComponent(G);
// return "https://quickchart.io/graphviz?layout=twopi&graph="+encodeURIComponent(G);
}
*/

// manage the control values and buttons /////////////////////////////////////////////////////////// fn: manageControls
function manageControls(){
 document.getElementById("output_valency").value = parseInt(document.getElementById("input_valency").value);
 document.getElementById("output_maxdepth").value = parseInt(document.getElementById("input_maxdepth").value);
 document.getElementById("output_Nnodes").value = calcSize();

 document.getElementById("output_Nnodes").classList.remove("toobig")
 document.getElementById("output_Nnodes").classList.remove("red","toobig")

 if (calcSize()>5000){
  document.getElementById("output_Nnodes").classList.add("toobig")
 } else if (calcSize()>2000){
  document.getElementById("output_Nnodes").classList.add("red")
 }
}

// how big is the graph? /////////////////////////////////////////////////////////////////////////// fn: calcSize
function calcSize(valency=null,maxdepth=null){
 // get the valency and maxdepth if they were not provided:
 if (valency==null) valency = parseInt(document.getElementById("input_valency").value);
 if (maxdepth==null) maxdepth = parseInt(document.getElementById("input_maxdepth").value);
 var N = 0;
 var Nnodes = 0;
 for (var d=0;d<=maxdepth;d++){
  if (d==0){
   N = 1;
  } else if (d==1){
   N = valency;
  } else {
   N = N*(valency-1);
  }
  Nnodes += N;
 }
 return Nnodes;
}


// process the automorphism //////////////////////////////////////////////////////////////////////// fn: processnode
function processnode(v,valency,verbose=false,debug=false){
 if (verbose) console.log("Processing node "+labelNode(v)); // +"                                   ie. "+v.toString()+" (valency="+valency+")");

 var indx = findNode(v,thenodeindex);
 var destindx = thenewnodeindex[v];
 if (v.length==0) destindx = thenewnodeindex["ROOT"];

 var onlyDrawDrawnNodes = document.getElementById("input_extent").checked;

 // has this node been drawn within the current extent of the graph?
 if (onlyDrawDrawnNodes && indx==undefined){
  if (verbose) console.log("    ... stopping at "+labelNode(v)+" [node not drawn]"); // v is off the drawn graph
  autoprogress.push(labelNode(v));
 } else if (destindx==undefined){
  if (verbose) console.log("    ... stopping at "+labelNode(v)+" [destination not drawn]"); // w is off the drawn graph
  autoprogress.push(labelNode(v));
 } else {
  if (autoprogress.indexOf(labelNode(v))>-1){
   if (verbose) console.log("    ... already done node "+labelNode(v));
  } else {
   autoprogress.push(labelNode(v));

   var w = thenodes[destindx]; // address of the destination node
   if (debug) console.log("AUTOMORPHISM: node "+labelNode(v)+" is moving to "+labelNode(w));

   // 1. retrieve the local action, f_v, at this node
   //    -- user-given or
   //    -- (constrained) random or
   //    -- same as at the reference node
   // [EVENTUALLY THESE WILL COME FROM USER INPUT]
   console.log("###\n### NOTE: using reference node's local action everywhere\n###");
   thelocalaction[indx] = localActionPermutation; // for now, use the reference node's local action everywhere

   if (thelocalaction[indx]==null){
    if (verbose) console.log("    ... no local action defined at "+labelNode(v)+", so stopping");
   } else {
    // 2. find this node's neighbours, vi
    var vi = findNeighbours(v,valency); // IN THE ORIGINAL GRAPH
    // 3. permute them according to the local action to give vif (remember that localAction() takes a list of nodes as its input, not a single node)
    var vif = localAction(vi,thelocalaction[indx],valency);
    // 4. find the node's destination's neighbours, wi
    var wi = findNeighbours(w,valency); // POST-MOVE


    if (debug) console.log(" +++ The neighbours of "+labelNode(v)+" are "+vi.map(labelNode).toString());
    if (debug) console.log(" +++ Under the local action they are "+vif.map(labelNode).toString());
    if (debug) console.log(" +++ Their destinations are "+wi.map(labelNode).toString());


    // 3. for each permuted neighbour:
    for (var i=0;i<vif.length;i++){
     if (debug) console.log("     +++ Working on "+labelNode(v)+" neighbour "+labelNode(vi[i])+" ("+findNode(vi[i],thenodeindex)+") -> "+labelNode(vif[i])+" ("+findNode(vif[i],thenodeindex)+") -> "+labelNode(wi[i])+" ("+findNode(wi[i],thenodeindex)+")");

     // find the index of this node's destination *in the "new" graph*
     var neighbourdestindx = findNode(wi[i],thenodeindex);

     // can we draw this destination node?
     if (neighbourdestindx==undefined){
      if (debug) console.log("   "+labelNode(vi[i])+" node destination "+labelNode(vif[i])+" is outside the drawn graph ");
      if (verbose) console.log("    ... skipping "+labelNode(vif[i])+" [destination not drawn]"); // v is off the drawn graph
     } else {

      // only process nodes which were drawn in the original graph:
      if (!onlyDrawDrawnNodes|findNode(vif[i],thenodeindex)!=undefined){
       thenewnodes[neighbourdestindx] = vif[i];

       // update the index for the post-automorphism graph (taking care with the root node):
       var thisnodestring = vif[i].toString();
       if (thisnodestring.length==0) thisnodestring = "ROOT";
       thenewnodeindex[thisnodestring] = neighbourdestindx;

       // how far did the node move?
       autodistance[vif[i].toString()] = nodeDistance(vif[i],wi[i]);
       if (debug) console.log(" ----------------------------------------------------------------- distance from "+labelNode(vif[i])+" to "+labelNode(wi[i])+" is "+autodistance[wi[i].toString()]);
       if (debug) console.log("   --- setting thenewnodeindex["+vif[i].toString()+"] to "+thenewnodeindex[vif[i].toString()]);

       // now work on this neighbour's neighbours:
       if (debug) console.log("Calling processnode(["+vif[i]+"],"+valency+"), ie. processnode(["+labelNode(vif[i])+"],"+valency+")");
       processnode(vif[i],valency);
      }

     }
    }
   }
  }
 }
 return 0;
}

// find the index of a node by its address ///////////////////////////////////////////////////////// fn: findNode
function findNode(v,nodeindex){
 if (v.length){
  return nodeindex[v];
 } else {
  return nodeindex["ROOT"];
 }
}

// find the distance between two nodes ///////////////////////////////////////////////////////////// fn: labelDistance
function nodeDistance(v,w){
 // inputs are node addresses, eg. [0,1,2,1]
 // remove common prefix:
 if (v.length>0 & w.length>0){
  while (v[0]==w[0]){
   v=v.slice(1);
   w=w.slice(1);
   if (v.length==0 | w.length==0){
    break;
   }
  }
 }
 // the count what path length is left
 var dist = v.length+w.length;
 return dist;
}

// HTML input labelling function ///////////////////////////////////////////////////////////////////// fn:setOutputValues
// function which looks for inputs and their labels (containing the input value), and sets the label
// (only called on page load, to set the initial labels)
function setOutputValues(){
 // display the calculated number of nodes that these control choices (valency, depth) will produce:
 document.getElementById("output_Nnodes").value = calcSize();

 var inputs = document.getElementsByTagName("input"); // get a list of the page inputs
 for (var i=0;i<inputs.length;i++){ // loop over the inputs
  outputID = inputs[i].id.replace('input_','output_');
  if (!!document.getElementById(outputID)){ // does an output tag for this control exist?
   document.getElementById(outputID).value = inputs[i].value; // set the value of the output to the input
  }
 }
}
</script>

</body>
</html>
