<!DOCTYPE html>
<head>
 <meta charset="utf-8">
 <title>Automorphism</title>
 <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans|Open+Sans+Condensed:Light&display=swap">
</head>
<body onload="run();">


<script>
// function to provide labels ///////////////////////////////////////////////////////////////////// fn:label
function label(n){
 return (n>=0 & n<thelabels.length ? thelabels[n] : "X"); // return 'X' if n is out of range
}
function labelNode(node){
 thelabel = node.map(label).join("");
 if (thelabel.length==0) thelabel = ROOTNODE;
 return thelabel;
}

// function to turn nodes and edges into dot output //////////////////////////////////////////////// fn: mkdot
function mkdot(nodes,edges,uselabels=false,refNode=[],destNode=[],refNeigh=[],destNeigh=[],localActionNeigh=[]){
 colours=['red','blue','green','magenta','cyan','black','yellow'];
 var thisgraph = 'graph {\n\tedge [penwidth=1]\n\tranksep=10\n';
 thisgraph += '\tnode [shape=circle, color=black, style=filled, fillcolor="#88888844", fontsize=14, fixedsize=true, fontcolor="#aaaaaa"]\n'
 thisgraph += '\t// EDGES\n';
 for (var i=0;i<theedges.length;i++){
  var from = thenodes[theedges[i][0]].join("");
  var to = thenodes[theedges[i][1]].join("");
  if (uselabels){
   var fromLabel = labelNode(thenodes[theedges[i][0]]);
   var toLabel = labelNode(thenodes[theedges[i][1]]);
  } else {
   var fromLabel = from;
   var toLabel = to;
  }
  if (fromLabel.length==0) fromLabel = ROOTNODE;
  if (toLabel.length==0) toLabel = ROOTNODE;
  thiscolour = colours[to[to.length-1]]
  thisgraph += '\t' + fromLabel + EDGESEP + toLabel + ' [color='+thiscolour+']\n';
 }

// if (refNode.length>0 & destNode.length>0 & refNeigh.length==destNeigh.length & refNeigh.length==localActionNeigh.length){
 if (refNeigh.length==destNeigh.length & refNeigh.length==localActionNeigh.length){
  // draw dashed edges showing the new edges
  // insert a comment for blanking out all of the unspecified (in the automorphism) nodes (just in case it is wanted)
  thisgraph += '\n\t// NO LABELS?\n';
  thisgraph += '//\t';
  for (var i=0;i<nodes.length;i++){
   thisgraph += labelNode(nodes[i])+',';
  }
  thisgraph = thisgraph.slice(0,thisgraph.length-1); // remove trailing comma
  thisgraph += ' [label=""]\n';

  thisgraph += '\n\t// AUTOMORPHISM\n';
  thisgraph += '\tedge [penwidth=5]\n';

  for (var i=0;i<localActionNeigh.length;i++){

   /* --- start colour */
   if (destNeigh[i].length<destNode.length){
    // "parent" neighbour, use the last entry of the reference node for the colour:
    thiscolour = colours[destNode[destNode.length-1]];
   } else {
    // "regular" neighbour, use the last entry for the colour:
    thiscolour = colours[destNeigh[i][destNeigh[i].length-1]];
   }
   /* --- end colour */

   thisgraph += '\t'+labelNode(destNode) + EDGESEP + labelNode(localActionNeigh[i]) + ' [style=dashed, color='+thiscolour+']\n';
  }
  // highlight and relabel the reference node and its neighbours
  thisgraph += '\t'+labelNode(refNode)+' [fillcolor=green, fontcolor=black, penwidth=5, label="'+labelNode(refNode)+'"]\n';
  for (var i=0;i<refNeigh.length;i++){
   thisgraph += '\t'+labelNode(refNeigh[i])+' [fillcolor=green, fontcolor=black, label="'+labelNode(refNeigh[i])+'"]\n';
  }
  // highlight and relabel the destination nodes
  thisgraph += '\t'+labelNode(destNode)+' [fillcolor=yellow, fontcolor=black, penwidth=5, label="'+labelNode(destNode)+'\\n'+labelNode(refNode)+'"]\n';
  for (var i=0;i<localActionNeigh.length;i++){
   thisgraph += '\t'+labelNode(localActionNeigh[i])+' [fillcolor=yellow, fontcolor=black, label="'+labelNode(localActionNeigh[i])+'\\n'+labelNode(refNeigh[i])+'"]\n';
  }

 } else {
  console.log("[mkdot] Wrong length");
 }

 thisgraph += '}\n';
 return thisgraph;
}

// function to find a d3 node with the given label ///////////////////////////////////////////////// fn: findlabel
function findlabel(nodes,label){
 var foundindex = -1;
 for (var i=0;i<nodes.length;i++){
  if (nodes[i].label==label){
   foundindex = i;
  }
 }
 return foundindex;
}


const Pi = Math.acos(-1);
const thelabels = "abcdefghijklmnopqrstuvwxyz0123456789".split(""); // used for dot language output
const EDGESEP = " -- "; // dot language output separator (-- or ->)
const ROOTNODE = "\u{d8}";

function run(){
 var maxdepth = 5;
 valency = 3;
 var valencyList = [];
 for (var v=0;v<valency;v++){
  valencyList.push(v);
 }

 // initialise
 thenodes = [];      // list of nodes by address
 thenodes[0] = [];   // root node
 theedges = [];      // pair-wise edges, using indices
 thenodeindex = [];  // associative array, index by node address

 // loop over all nodes and add children to those at the (current) maximum depth
 for (var d=0;d<maxdepth;d++){
  for (var i=0;i<thenodes.length;i++){
   if (thenodes[i].length==d){
    for (var v=0;v<valency;v++){
     if (thenodes[i][thenodes[i].length-1]!=v){ // but only add this node if it really exists (ie. not doubling back on the path)
      thenodes[thenodes.length] = thenodes[i].concat(v);
      // store the index of each node address as well (to aid searching)
      thenodeindex[thenodes[thenodes.length-1].toString()] = thenodes.length-1;
      // and add an edge at the same time
      theedges.push([i,thenodes.length-1]);
     }
    }
   }
  }
 }


 // now define the automorphism: [THESE WILL COME FROM USER INPUT]
 if (1){
  autoFrom = [0,1,2];
  autoTo = [1,2];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }
 if (0){
  autoFrom = [];
  autoTo = [1,2];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }
 if (0){
  autoFrom = [2,0,1];
  autoTo = [1,0,2];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }
 if (0){
  autoFrom = [2,1,2];
  autoTo = [1,0,2];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }
 if (1){
  autoFrom = [2,1,2,1];
  autoTo = [1,0,2];
  localActionPermutation = permutationCyclic(valencyList,1); // for example
 }

 // get neighbours
 autoNeighbours = findNeighbours(autoFrom,valency);  // these nodes...
 toNeighbours = findNeighbours(autoTo,valency);     // ...map to these nodes
 permNeighbours = localAction(toNeighbours,localActionPermutation,valency);
 

 // map these neighbours according to the localAction:
// toNeighbours = [];
// for (var v=0;v<valency;v++){ // equivalently, autoNeighbours.length
//  toNeighbours.push(permute(autoNeighbours[v],localAction,valency,1));
// }

 console.log("Reference node moves:");
 console.log(labelNode(autoFrom)+" --> "+labelNode(autoTo));
 console.log(" ");
 console.log("Node label --> maps to --> permutes to");
 for (var i=0;i<autoNeighbours.length;i++){
  console.log(autoNeighbours[i].map(label).toString()+"\t-->\t"+toNeighbours[i].map(label).toString()+"\t-->\t"+permNeighbours[i].map(label).toString());
 }


 // create the dot graph //////////////////////////////////////////////////////////////////////////////// make the graph
 drawFrom = [autoFrom].concat(autoNeighbours);
 drawTo = [autoTo].concat(permNeighbours);
 G=mkdot(thenodes,theedges,true,autoFrom,autoTo,autoNeighbours,toNeighbours,permNeighbours);
 console.log(G);
 // feed it to:
 //		https://dreampuf.github.io/GraphvizOnline/


} // end run()

// random integers ////////////////////////////////////////////////////////////////////////////////////// fn: randomInt
function randomInt(n=1){
 return Math.floor(Math.random()*n); // random integer from the set [0, 1, ..., n-1]
}

// cyclically permute a given list (by a specified "distance") ////////////////////////////////////////// fn: permutationCyclic
function permutationCyclic(list,dist=0){
 var out = Array(list.length); // initialise
 while (dist>list.length) dist-=list.length; // avoid winding
 while (dist<0) dist+=list.length; // avoid winding
 for (var i=0;i<(list.length-dist);i++) out[i]=list[i+dist]; // 0 ... dist
 for (var i=list.length-dist;i<list.length;i++) out[i]=list[i+dist-list.length]; // dist+1 ... end
 return out;
}

// randomly permute a given list //////////////////////////////////////////////////////////////////////// fn: permutationRandom
function permutationRandom(list){
 var inlist = Array(list.length); // initialise
 var out = Array(list.length); // initialise
 for (var i=0;i<list.length;i++) inlist[i] = list[i]; // make a copy
 for (var i=0;i<list.length;i++) out[i] = inlist.splice(randomInt(inlist.length),1); // extract the copy in random order
 return out;
}

// test a permutation vector for legality /////////////////////////////////////////////////////////////// fn: testPermuation
function testPermutation(perm,valency){
 // test for a valid permutation
 if (perm.length==valency){ // right size?
  for (var p=0;p<perm.length;p++){
   if (perm.indexOf(perm[p])!=p){ // repeated entries?
    console.log("ERROR: invalid permutation (repeated entries)");
    return false;
   }
  }
 } else {
  console.log("ERROR: permutation length is not equal to the valency");
  return false;
 }
 return true;
}

// permute a given list using the provided permutation ////////////////////////////////////////////////// fn: permute
function localAction(list,perm,valency){
 // takes a list of a node's neighbours (ie. list length = valency) and permutes them

 if (testPermutation(perm,valency)){
  // legal permutation, so perform the operation
  var out = Array(list.length);
  for (var i=0;i<list.length;i++){
//reversed   out[i] = list[perm[i]]; // permute elements: local action (ie swap the elements of the list around with each other)
   out[perm[i]] = list[i]; // permute elements: local action (ie swap the elements of the list around with each other)
  }
  return out;
 } else {
  return undefined;
 }
}

/*
// permute a given list using the provided permutation ////////////////////////////////////////////////// fn: permute
function permute(list,perm,valency){
 // n is the number of elements *from the end* to permute

 if (testPermutation(perm,valency)){
  // legal permutation, so perform the operation
  var out = Array(list.length);
  for (var i=0;i<list.length-n;i++){
   out[i] = list[i]; // simply copy non-permuting elements
  }
  for (var i=list.length-n;i<list.length;i++){
   out[i] = perm[list[i]]; // permute elements of the list: "regular" permutation
//   out[i] = list[perm[i]]; // permute the list: local action
  }
  return out;
 } else {
  return undefined;
 }
}
*/

// find the neighbours of a given node, for a given valency //////////////////////////////////////////////// fn: findNeighbours
function findNeighbours(node,valency){
 neighbours = Array(valency); // initialise
 for (var v=0;v<valency;v++){
  if (v==node[node.length-1]){ // check for the "parent" node
   // add the neighbour towards the root node
   neighbours[v] = node.slice(0,node.length-1);
  } else {
   neighbours[v] = node.concat(v);
  }
 }
 return neighbours;
}


</script>

</body>
</html>
